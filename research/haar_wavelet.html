<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Haar Wavelet Compression Walkthrough</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .section {
            margin: 30px 0;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .section h3 {
            color: #555;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }

        .section p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
            font-size: 1.05em;
        }

        .section ul, .section ol {
            margin-left: 30px;
            color: #555;
            line-height: 1.8;
        }

        .section li {
            margin: 8px 0;
        }

        .formula {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
        }

        .upload-box {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            margin: 20px 0;
        }

        .upload-box:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-box h3 {
            color: #333;
            margin-bottom: 15px;
        }

        .upload-box input[type="file"] {
            display: none;
        }

        .upload-button {
            display: inline-block;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 600;
        }

        .upload-button:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .preview-img {
            max-width: 100%;
            max-height: 300px;
            margin-top: 15px;
            border-radius: 8px;
            display: none;
        }

        .preview-img.visible {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            font-size: 0.95em;
        }

        .control-group input[type="range"] {
            width: 200px;
        }

        .control-group .value-display {
            text-align: center;
            color: #667eea;
            font-weight: 700;
            font-size: 1.1em;
        }

        button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .visualization {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .visualization h3 {
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .canvas-item {
            text-align: center;
        }

        .canvas-item h4 {
            color: #555;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .canvas-item canvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            background: #f0f0f0;
        }

        .stats {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .stats h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .stats p {
            color: #555;
            margin: 8px 0;
            font-size: 0.95em;
        }

        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }

        .info-box {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            margin: 15px 0;
        }

        code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d63384;
        }

        .step-indicator {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Haar Wavelet Compression</h1>
        <p class="subtitle">An Interactive Visual Walkthrough</p>

        <!-- Introduction Section -->
        <div class="section">
            <h2>üéØ What is Haar Wavelet Compression?</h2>
            <p>
                Haar wavelet compression is a mathematical technique used to compress images by transforming them into a representation that separates the image into
                <strong>low-frequency (smooth) components</strong> and <strong>high-frequency (detail) components</strong>.
                This allows us to identify and discard less important details while preserving the overall structure of the image.
            </p>
            <div class="highlight">
                <p><strong>Key Insight:</strong> Most of the important visual information in an image is contained in the low-frequency components.
                By removing small high-frequency coefficients (details), we can achieve compression with minimal visual loss.</p>
            </div>
        </div>

        <!-- Theory Section -->
        <div class="section">
            <h2>üìö The Mathematics Behind Haar Wavelets</h2>

            <h3><span class="step-indicator">Step 1</span>The Haar Transform</h3>
            <p>
                The Haar wavelet transform works by repeatedly applying two operations to pairs of values:
            </p>
            <ul>
                <li><strong>Averaging:</strong> Compute the average of two adjacent values ‚Üí captures the <em>approximation</em> (low-frequency)</li>
                <li><strong>Differencing:</strong> Compute the difference between values ‚Üí captures the <em>detail</em> (high-frequency)</li>
            </ul>

            <div class="formula">
                Average = (a + b) / 2<br>
                Detail = (a - b) / 2
            </div>

            <h3><span class="step-indicator">Step 2</span>2D Haar Transform for Images</h3>
            <p>For images, we apply the Haar transform in both dimensions:</p>
            <ol>
                <li><strong>Horizontal Transform:</strong> Apply the transform to each row</li>
                <li><strong>Vertical Transform:</strong> Apply the transform to each column of the result</li>
            </ol>
            <p>This produces four quadrants in the transformed image:</p>
            <ul>
                <li><strong>Top-Left (LL):</strong> Low-frequency in both directions ‚Üí approximation of the image</li>
                <li><strong>Top-Right (LH):</strong> Horizontal details (edges)</li>
                <li><strong>Bottom-Left (HL):</strong> Vertical details (edges)</li>
                <li><strong>Bottom-Right (HH):</strong> Diagonal details</li>
            </ul>

            <h3><span class="step-indicator">Step 3</span>Compression Through Thresholding</h3>
            <p>
                After transformation, we apply a <strong>threshold</strong> to the wavelet coefficients. Any coefficient with an absolute value
                below the threshold is set to zero. Since detail coefficients (LH, HL, HH) are often small, many can be discarded:
            </p>
            <div class="formula">
                if |coefficient| &lt; threshold: coefficient = 0
            </div>
            <p>The more coefficients we set to zero, the higher the compression ratio, but the more detail we lose.</p>

            <h3><span class="step-indicator">Step 4</span>Inverse Transform</h3>
            <p>To reconstruct the image, we reverse the process:</p>
            <div class="formula">
                a = average + detail<br>
                b = average - detail
            </div>
            <p>Apply the inverse transform vertically, then horizontally, to recover the compressed image.</p>
        </div>

        <!-- Interactive Demo Section -->
        <div class="section">
            <h2>üî¨ Interactive Demo</h2>
            <p>Upload your own image to see how Haar wavelet compression works in real-time!</p>

            <div class="upload-box">
                <h3>Upload Image</h3>
                <label for="imageInput" class="upload-button">Choose Image</label>
                <input type="file" id="imageInput" accept="image/*">
                <img id="imagePreview" class="preview-img">
            </div>

            <div class="controls" id="controls" style="display: none;">
                <div class="control-group">
                    <label for="levelsSlider">Decomposition Levels:</label>
                    <input type="range" id="levelsSlider" min="1" max="5" value="3">
                    <div class="value-display" id="levelsValue">3</div>
                </div>
                <div class="control-group">
                    <label for="thresholdSlider">Threshold (Compression):</label>
                    <input type="range" id="thresholdSlider" min="0" max="100" value="10">
                    <div class="value-display" id="thresholdValue">10</div>
                </div>
                <button id="processButton">Apply Transform</button>
            </div>

            <div class="info-box" id="processingInfo" style="display: none;">
                <p>‚öôÔ∏è Processing your image... This may take a moment for large images.</p>
            </div>
        </div>

        <!-- Visualization Section -->
        <div class="visualization" id="visualization" style="display: none;">
            <h3>Transformation Results - Color Channels</h3>

            <!-- Row 1: Original and Coefficient Visualizations -->
            <div class="canvas-grid">
                <div class="canvas-item">
                    <h4>Original Image</h4>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Red Channel Coefficients</h4>
                    <canvas id="coeffCanvasR"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Green Channel Coefficients</h4>
                    <canvas id="coeffCanvasG"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Blue Channel Coefficients</h4>
                    <canvas id="coeffCanvasB"></canvas>
                </div>
            </div>

            <!-- Row 2: Thresholded Visualizations -->
            <div class="canvas-grid">
                <div class="canvas-item">
                    <h4>Red After Thresholding</h4>
                    <canvas id="thresholdCanvasR"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Green After Thresholding</h4>
                    <canvas id="thresholdCanvasG"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Blue After Thresholding</h4>
                    <canvas id="thresholdCanvasB"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Composite After Thresholding</h4>
                    <canvas id="thresholdCanvasComposite"></canvas>
                </div>
            </div>

            <!-- Row 3: Reconstructed Images -->
            <div class="canvas-grid">
                <div class="canvas-item">
                    <h4>Red Reconstructed</h4>
                    <canvas id="reconstructedCanvasR"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Green Reconstructed</h4>
                    <canvas id="reconstructedCanvasG"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Blue Reconstructed</h4>
                    <canvas id="reconstructedCanvasB"></canvas>
                </div>
                <div class="canvas-item">
                    <h4>Final Composite (Compressed)</h4>
                    <canvas id="reconstructedCanvasComposite"></canvas>
                </div>
            </div>

            <div class="stats" id="stats"></div>
        </div>

        <!-- Understanding the Results Section -->
        <div class="section">
            <h2>üîç Understanding the Results</h2>

            <h3>What You're Seeing</h3>
            <p><strong>Wavelet Coefficients (Visualized):</strong></p>
            <ul>
                <li>The <strong>top-left quadrant</strong> shows a smaller version of your image (approximation coefficients)</li>
                <li>The other three quadrants show the <strong>detail coefficients</strong> (horizontal, vertical, and diagonal edges)</li>
                <li>Brighter areas indicate larger coefficient values</li>
            </ul>

            <p><strong>After Thresholding:</strong></p>
            <ul>
                <li>This shows which coefficients survived the threshold</li>
                <li>Black areas represent coefficients that were set to zero (compressed away)</li>
                <li>More black = higher compression ratio</li>
            </ul>

            <p><strong>Reconstructed Image:</strong></p>
            <ul>
                <li>This is the final compressed and decompressed image</li>
                <li>Compare it to the original to see the quality loss</li>
                <li>Higher threshold = more compression but lower quality</li>
            </ul>

            <div class="highlight">
                <p><strong>Experiment:</strong> Try adjusting the threshold slider. Low values preserve more detail,
                while high values increase compression but introduce artifacts.</p>
            </div>
        </div>

        <!-- Applications Section -->
        <div class="section">
            <h2>üöÄ Real-World Applications</h2>
            <p>Haar wavelets and similar wavelet transforms are used in:</p>
            <ul>
                <li><strong>JPEG 2000:</strong> An image compression standard using wavelet transforms</li>
                <li><strong>Video Compression:</strong> Compressing individual frames in video codecs</li>
                <li><strong>Image Denoising:</strong> Removing noise by thresholding small coefficients</li>
                <li><strong>Feature Detection:</strong> Finding edges and patterns in computer vision</li>
                <li><strong>Fingerprint Compression:</strong> FBI uses wavelet compression for fingerprint databases</li>
                <li><strong>Medical Imaging:</strong> Compressing MRI and CT scans while preserving diagnostic information</li>
            </ul>
        </div>

        <!-- Advanced Topics Section -->
        <div class="section">
            <h2>üéì Advanced Topics</h2>

            <h3>Decomposition Levels</h3>
            <p>
                The "Decomposition Levels" parameter controls how many times we recursively apply the Haar transform to the approximation quadrant.
                More levels = more compression potential, but also more computation.
            </p>

            <h3>Other Wavelet Families</h3>
            <p>
                While Haar is the simplest wavelet, there are many others with different properties:
            </p>
            <ul>
                <li><strong>Daubechies wavelets:</strong> Smoother, better for natural images</li>
                <li><strong>Coiflets:</strong> Symmetric, good for signal processing</li>
                <li><strong>Symlets:</strong> Near-symmetric, used in image analysis</li>
            </ul>

            <h3>Quantization</h3>
            <p>
                In practical compression (like JPEG 2000), coefficients aren't just thresholded‚Äîthey're <em>quantized</em>,
                meaning they're rounded to a smaller set of values. This allows for even more compression through entropy coding.
            </p>
        </div>

        <!-- Further Reading Section -->
        <div class="section">
            <h2>üìñ Further Reading</h2>
            <ul>
                <li>St√©phane Mallat - "A Wavelet Tour of Signal Processing"</li>
                <li>Ingrid Daubechies - "Ten Lectures on Wavelets"</li>
                <li>JPEG 2000 Standard Documentation</li>
                <li>Wavelet Transform on Wikipedia</li>
            </ul>
        </div>
    </div>

    <script>
        let originalImage = null;
        let originalImageData = null;

        const imageInput = document.getElementById('imageInput');
        const imagePreview = document.getElementById('imagePreview');
        const controls = document.getElementById('controls');
        const processButton = document.getElementById('processButton');
        const levelsSlider = document.getElementById('levelsSlider');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const levelsValue = document.getElementById('levelsValue');
        const thresholdValue = document.getElementById('thresholdValue');
        const processingInfo = document.getElementById('processingInfo');
        const visualization = document.getElementById('visualization');
        const stats = document.getElementById('stats');

        const originalCanvas = document.getElementById('originalCanvas');
        const coeffCanvasR = document.getElementById('coeffCanvasR');
        const coeffCanvasG = document.getElementById('coeffCanvasG');
        const coeffCanvasB = document.getElementById('coeffCanvasB');
        const thresholdCanvasR = document.getElementById('thresholdCanvasR');
        const thresholdCanvasG = document.getElementById('thresholdCanvasG');
        const thresholdCanvasB = document.getElementById('thresholdCanvasB');
        const thresholdCanvasComposite = document.getElementById('thresholdCanvasComposite');
        const reconstructedCanvasR = document.getElementById('reconstructedCanvasR');
        const reconstructedCanvasG = document.getElementById('reconstructedCanvasG');
        const reconstructedCanvasB = document.getElementById('reconstructedCanvasB');
        const reconstructedCanvasComposite = document.getElementById('reconstructedCanvasComposite');

        // Update slider displays
        levelsSlider.addEventListener('input', (e) => {
            levelsValue.textContent = e.target.value;
        });

        thresholdSlider.addEventListener('input', (e) => {
            thresholdValue.textContent = e.target.value;
        });

        // Handle image upload
        imageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    imagePreview.src = e.target.result;
                    imagePreview.classList.add('visible');
                    controls.style.display = 'flex';

                    // Store original image data
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0);
                    originalImageData = tempCtx.getImageData(0, 0, img.width, img.height);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Process button click
        processButton.addEventListener('click', processImage);

        function processImage() {
            if (!originalImage) return;

            processingInfo.style.display = 'block';
            visualization.style.display = 'none';

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    const levels = parseInt(levelsSlider.value);
                    const threshold = parseFloat(thresholdSlider.value);

                    const width = originalImage.width;
                    const height = originalImage.height;

                    // Extract RGB channels
                    const channels = extractRGBChannels(originalImageData);

                    // Process each channel
                    const results = {
                        r: processChannel(channels.r, width, height, levels, threshold),
                        g: processChannel(channels.g, width, height, levels, threshold),
                        b: processChannel(channels.b, width, height, levels, threshold)
                    };

                    // Calculate overall statistics
                    const totalCoeffs = results.r.coefficients.length * 3;
                    const totalNonZeroBefore = results.r.nonZeroBefore + results.g.nonZeroBefore + results.b.nonZeroBefore;
                    const totalNonZeroAfter = results.r.nonZeroAfter + results.g.nonZeroAfter + results.b.nonZeroAfter;
                    const totalEliminated = totalNonZeroBefore - totalNonZeroAfter;
                    const compressionRatio = ((totalEliminated / totalCoeffs) * 100).toFixed(2);

                    // Calculate composite PSNR
                    const compositeMSE = (results.r.mse + results.g.mse + results.b.mse) / 3;
                    const compositePSNR = calculatePSNR(compositeMSE);

                    // Visualize results
                    visualizeChannelResults(originalImageData, results, width, height);

                    // Update stats
                    stats.innerHTML = `
                        <h4>Compression Statistics - All Channels</h4>
                        <p><strong>Original Dimensions:</strong> ${width} √ó ${height} pixels</p>
                        <p><strong>Decomposition Levels:</strong> ${levels}</p>
                        <p><strong>Threshold Value:</strong> ${threshold}</p>
                        <p><strong>Total Coefficients (RGB):</strong> ${totalCoeffs.toLocaleString()}</p>
                        <p><strong>Non-zero Before Threshold:</strong> ${totalNonZeroBefore.toLocaleString()}</p>
                        <p><strong>Non-zero After Threshold:</strong> ${totalNonZeroAfter.toLocaleString()}</p>
                        <p><strong>Coefficients Eliminated:</strong> ${totalEliminated.toLocaleString()} (${compressionRatio}%)</p>
                        <p><strong>Composite PSNR:</strong> ${compositePSNR.toFixed(2)} dB</p>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #667eea;">
                            <p><strong>Per-Channel PSNR:</strong></p>
                            <p style="color: #dc3545;">‚Ä¢ Red: ${results.r.psnr.toFixed(2)} dB (${results.r.compressionRatio}% eliminated)</p>
                            <p style="color: #28a745;">‚Ä¢ Green: ${results.g.psnr.toFixed(2)} dB (${results.g.compressionRatio}% eliminated)</p>
                            <p style="color: #007bff;">‚Ä¢ Blue: ${results.b.psnr.toFixed(2)} dB (${results.b.compressionRatio}% eliminated)</p>
                        </div>
                        <p style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #667eea;">
                            <em>Higher PSNR = better quality. PSNR > 30 dB is generally considered good quality.</em>
                        </p>
                    `;

                    visualization.style.display = 'block';
                    processingInfo.style.display = 'none';

                } catch (error) {
                    console.error('Processing error:', error);
                    alert('Error processing image: ' + error.message);
                    processingInfo.style.display = 'none';
                }
            }, 50);
        }

        // Extract RGB channels from image data
        function extractRGBChannels(imageData) {
            const data = imageData.data;
            const numPixels = imageData.width * imageData.height;

            const r = new Float32Array(numPixels);
            const g = new Float32Array(numPixels);
            const b = new Float32Array(numPixels);

            for (let i = 0; i < numPixels; i++) {
                r[i] = data[i * 4];
                g[i] = data[i * 4 + 1];
                b[i] = data[i * 4 + 2];
            }

            return { r, g, b };
        }

        // Process a single channel through Haar transform
        function processChannel(channelData, width, height, levels, threshold) {
            // Apply Haar wavelet transform
            const coefficients = haarTransform2D(channelData, width, height, levels);

            // Count coefficients before thresholding
            const totalCoeffs = coefficients.length;
            const nonZeroBefore = coefficients.filter(c => Math.abs(c) > 0.001).length;

            // Apply thresholding
            const thresholdedCoeffs = applyThreshold(coefficients, threshold);

            // Count after thresholding
            const nonZeroAfter = thresholdedCoeffs.filter(c => Math.abs(c) > 0.001).length;
            const zerosAdded = nonZeroBefore - nonZeroAfter;
            const compressionRatio = ((zerosAdded / totalCoeffs) * 100).toFixed(2);

            // Inverse transform to reconstruct
            const reconstructed = inverseHaarTransform2D(thresholdedCoeffs, width, height, levels);

            // Calculate quality metrics
            const mse = calculateMSE(channelData, reconstructed);
            const psnr = calculatePSNR(mse);

            return {
                coefficients,
                thresholdedCoeffs,
                reconstructed,
                nonZeroBefore,
                nonZeroAfter,
                compressionRatio,
                mse,
                psnr
            };
        }

        // Convert RGBA to grayscale (kept for compatibility)
        function rgbaToGrayscale(imageData) {
            const data = imageData.data;
            const grayscale = new Float32Array(imageData.width * imageData.height);

            for (let i = 0; i < grayscale.length; i++) {
                const r = data[i * 4];
                const g = data[i * 4 + 1];
                const b = data[i * 4 + 2];
                grayscale[i] = 0.299 * r + 0.587 * g + 0.114 * b;
            }

            return grayscale;
        }

        // 1D Haar transform
        function haarTransform1D(signal) {
            const n = signal.length;
            if (n < 2) return signal;

            const result = new Float32Array(n);
            const half = n / 2;

            // Averages (approximation)
            for (let i = 0; i < half; i++) {
                result[i] = (signal[2 * i] + signal[2 * i + 1]) / 2;
            }

            // Differences (details)
            for (let i = 0; i < half; i++) {
                result[half + i] = (signal[2 * i] - signal[2 * i + 1]) / 2;
            }

            return result;
        }

        // 2D Haar transform with multiple levels
        function haarTransform2D(data, width, height, levels) {
            // Copy data
            let result = new Float32Array(data);

            let currentWidth = width;
            let currentHeight = height;

            for (let level = 0; level < levels; level++) {
                // Transform rows
                for (let y = 0; y < currentHeight; y++) {
                    const row = new Float32Array(currentWidth);
                    for (let x = 0; x < currentWidth; x++) {
                        row[x] = result[y * width + x];
                    }
                    const transformedRow = haarTransform1D(row);
                    for (let x = 0; x < currentWidth; x++) {
                        result[y * width + x] = transformedRow[x];
                    }
                }

                // Transform columns
                for (let x = 0; x < currentWidth; x++) {
                    const col = new Float32Array(currentHeight);
                    for (let y = 0; y < currentHeight; y++) {
                        col[y] = result[y * width + x];
                    }
                    const transformedCol = haarTransform1D(col);
                    for (let y = 0; y < currentHeight; y++) {
                        result[y * width + x] = transformedCol[y];
                    }
                }

                // Next level works on smaller region
                currentWidth /= 2;
                currentHeight /= 2;

                if (currentWidth < 2 || currentHeight < 2) break;
            }

            return result;
        }

        // Apply threshold to coefficients
        function applyThreshold(coefficients, threshold) {
            const result = new Float32Array(coefficients.length);
            for (let i = 0; i < coefficients.length; i++) {
                if (Math.abs(coefficients[i]) >= threshold) {
                    result[i] = coefficients[i];
                } else {
                    result[i] = 0;
                }
            }
            return result;
        }

        // 1D Inverse Haar transform
        function inverseHaarTransform1D(signal) {
            const n = signal.length;
            if (n < 2) return signal;

            const result = new Float32Array(n);
            const half = n / 2;

            for (let i = 0; i < half; i++) {
                const avg = signal[i];
                const diff = signal[half + i];
                result[2 * i] = avg + diff;
                result[2 * i + 1] = avg - diff;
            }

            return result;
        }

        // 2D Inverse Haar transform
        function inverseHaarTransform2D(data, width, height, levels) {
            let result = new Float32Array(data);

            // Calculate sizes for each level
            const sizes = [];
            let w = width, h = height;
            for (let i = 0; i < levels; i++) {
                w /= 2;
                h /= 2;
                if (w < 2 || h < 2) break;
                sizes.push({ width: w, height: h });
            }

            // Apply inverse transforms in reverse order
            for (let level = sizes.length - 1; level >= 0; level--) {
                let currentWidth = sizes[level].width * 2;
                let currentHeight = sizes[level].height * 2;

                // Inverse transform columns
                for (let x = 0; x < currentWidth; x++) {
                    const col = new Float32Array(currentHeight);
                    for (let y = 0; y < currentHeight; y++) {
                        col[y] = result[y * width + x];
                    }
                    const transformedCol = inverseHaarTransform1D(col);
                    for (let y = 0; y < currentHeight; y++) {
                        result[y * width + x] = transformedCol[y];
                    }
                }

                // Inverse transform rows
                for (let y = 0; y < currentHeight; y++) {
                    const row = new Float32Array(currentWidth);
                    for (let x = 0; x < currentWidth; x++) {
                        row[x] = result[y * width + x];
                    }
                    const transformedRow = inverseHaarTransform1D(row);
                    for (let x = 0; x < currentWidth; x++) {
                        result[y * width + x] = transformedRow[x];
                    }
                }
            }

            return result;
        }

        // Calculate Mean Squared Error
        function calculateMSE(original, reconstructed) {
            let sum = 0;
            for (let i = 0; i < original.length; i++) {
                const diff = original[i] - reconstructed[i];
                sum += diff * diff;
            }
            return sum / original.length;
        }

        // Calculate Peak Signal-to-Noise Ratio
        function calculatePSNR(mse) {
            if (mse === 0) return Infinity;
            const maxPixel = 255;
            return 10 * Math.log10((maxPixel * maxPixel) / mse);
        }

        // Visualize all channel results
        function visualizeChannelResults(originalData, results, width, height) {
            // Original image
            originalCanvas.width = width;
            originalCanvas.height = height;
            const origCtx = originalCanvas.getContext('2d');
            origCtx.putImageData(originalData, 0, 0);

            // Red channel coefficients
            coeffCanvasR.width = width;
            coeffCanvasR.height = height;
            visualizeCoefficients(coeffCanvasR, results.r.coefficients, width, height);

            // Green channel coefficients
            coeffCanvasG.width = width;
            coeffCanvasG.height = height;
            visualizeCoefficients(coeffCanvasG, results.g.coefficients, width, height);

            // Blue channel coefficients
            coeffCanvasB.width = width;
            coeffCanvasB.height = height;
            visualizeCoefficients(coeffCanvasB, results.b.coefficients, width, height);

            // Red thresholded
            thresholdCanvasR.width = width;
            thresholdCanvasR.height = height;
            visualizeCoefficients(thresholdCanvasR, results.r.thresholdedCoeffs, width, height);

            // Green thresholded
            thresholdCanvasG.width = width;
            thresholdCanvasG.height = height;
            visualizeCoefficients(thresholdCanvasG, results.g.thresholdedCoeffs, width, height);

            // Blue thresholded
            thresholdCanvasB.width = width;
            thresholdCanvasB.height = height;
            visualizeCoefficients(thresholdCanvasB, results.b.thresholdedCoeffs, width, height);

            // Composite thresholded (combined RGB visualization)
            thresholdCanvasComposite.width = width;
            thresholdCanvasComposite.height = height;
            visualizeCompositeCoefficients(thresholdCanvasComposite, results.r.thresholdedCoeffs,
                results.g.thresholdedCoeffs, results.b.thresholdedCoeffs, width, height);

            // Red reconstructed
            reconstructedCanvasR.width = width;
            reconstructedCanvasR.height = height;
            visualizeSingleChannel(reconstructedCanvasR, results.r.reconstructed, width, height, 'r');

            // Green reconstructed
            reconstructedCanvasG.width = width;
            reconstructedCanvasG.height = height;
            visualizeSingleChannel(reconstructedCanvasG, results.g.reconstructed, width, height, 'g');

            // Blue reconstructed
            reconstructedCanvasB.width = width;
            reconstructedCanvasB.height = height;
            visualizeSingleChannel(reconstructedCanvasB, results.b.reconstructed, width, height, 'b');

            // Composite reconstructed (full color)
            reconstructedCanvasComposite.width = width;
            reconstructedCanvasComposite.height = height;
            const reconCtx = reconstructedCanvasComposite.getContext('2d');
            const reconImageData = reconCtx.createImageData(width, height);

            for (let i = 0; i < results.r.reconstructed.length; i++) {
                reconImageData.data[i * 4] = Math.max(0, Math.min(255, Math.round(results.r.reconstructed[i])));
                reconImageData.data[i * 4 + 1] = Math.max(0, Math.min(255, Math.round(results.g.reconstructed[i])));
                reconImageData.data[i * 4 + 2] = Math.max(0, Math.min(255, Math.round(results.b.reconstructed[i])));
                reconImageData.data[i * 4 + 3] = 255;
            }

            reconCtx.putImageData(reconImageData, 0, 0);
        }

        // Visualize a single channel in its color
        function visualizeSingleChannel(canvas, channelData, width, height, channel) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            for (let i = 0; i < channelData.length; i++) {
                const value = Math.max(0, Math.min(255, Math.round(channelData[i])));

                if (channel === 'r') {
                    imageData.data[i * 4] = value;
                    imageData.data[i * 4 + 1] = 0;
                    imageData.data[i * 4 + 2] = 0;
                } else if (channel === 'g') {
                    imageData.data[i * 4] = 0;
                    imageData.data[i * 4 + 1] = value;
                    imageData.data[i * 4 + 2] = 0;
                } else if (channel === 'b') {
                    imageData.data[i * 4] = 0;
                    imageData.data[i * 4 + 1] = 0;
                    imageData.data[i * 4 + 2] = value;
                }
                imageData.data[i * 4 + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Visualize composite coefficients in color
        function visualizeCompositeCoefficients(canvas, rCoeffs, gCoeffs, bCoeffs, width, height) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            // Find min and max for each channel
            function findMinMax(coeffs) {
                let min = Infinity, max = -Infinity;
                for (let i = 0; i < coeffs.length; i++) {
                    if (coeffs[i] < min) min = coeffs[i];
                    if (coeffs[i] > max) max = coeffs[i];
                }
                return { min, max, range: max - min };
            }

            const rStats = findMinMax(rCoeffs);
            const gStats = findMinMax(gCoeffs);
            const bStats = findMinMax(bCoeffs);

            for (let i = 0; i < rCoeffs.length; i++) {
                const rNorm = rStats.range > 0 ? ((rCoeffs[i] - rStats.min) / rStats.range) * 255 : 128;
                const gNorm = gStats.range > 0 ? ((gCoeffs[i] - gStats.min) / gStats.range) * 255 : 128;
                const bNorm = bStats.range > 0 ? ((bCoeffs[i] - bStats.min) / bStats.range) * 255 : 128;

                imageData.data[i * 4] = Math.round(rNorm);
                imageData.data[i * 4 + 1] = Math.round(gNorm);
                imageData.data[i * 4 + 2] = Math.round(bNorm);
                imageData.data[i * 4 + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Visualize wavelet coefficients
        function visualizeCoefficients(canvas, coefficients, width, height) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(width, height);

            // Find min and max for normalization
            let min = Infinity, max = -Infinity;
            for (let i = 0; i < coefficients.length; i++) {
                if (coefficients[i] < min) min = coefficients[i];
                if (coefficients[i] > max) max = coefficients[i];
            }

            const range = max - min;

            for (let i = 0; i < coefficients.length; i++) {
                // Normalize to 0-255
                const normalized = range > 0 ? ((coefficients[i] - min) / range) * 255 : 128;
                const value = Math.round(normalized);

                imageData.data[i * 4] = value;
                imageData.data[i * 4 + 1] = value;
                imageData.data[i * 4 + 2] = value;
                imageData.data[i * 4 + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
        }
    </script>
</body>
</html>
