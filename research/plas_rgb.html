<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLAS RGB - Parallel Linear Assignment Sorting</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            text-align: center;
            color: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .container {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1800px;
            width: 100%;
            margin: 0 auto;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .controls-panel {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .viewer-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e0e0e0;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .info-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .info-box h3 {
            margin-bottom: 10px;
            color: #667eea;
            font-size: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }

        .info-label {
            font-weight: 600;
            color: #666;
        }

        .info-value {
            color: #333;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            font-size: 13px;
            text-align: center;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 5px;
            font-size: 13px;
            line-height: 1.6;
        }

        .instructions h4 {
            margin-bottom: 10px;
            color: #856404;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
        }

        .image-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .image-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .image-section h3 {
            font-size: 16px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .canvas-wrapper {
            background: #1a1a2e;
            border-radius: 5px;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }

        canvas {
            max-width: 100%;
            height: auto;
            image-rendering: pixelated;
            border-radius: 3px;
        }

        input[type="range"] {
            width: 100%;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .metric-card {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .metric-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .metric-label {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <header>
        <h1>üé® PLAS RGB Sorter</h1>
        <p>Parallel Linear Assignment Sorting for RGB Images</p>
    </header>

    <div class="container">
        <div class="controls-panel panel">
            <div class="control-group">
                <label>Load Image</label>
                <div class="file-input-wrapper">
                    <input type="file" id="imageFile" accept="image/*" />
                    <label for="imageFile" class="file-input-label">
                        üìÅ Choose Image File
                    </label>
                </div>
            </div>

            <div class="control-group">
                <button class="btn-secondary" id="loadSample">
                    üñºÔ∏è Load Sample Image
                </button>
            </div>

            <div id="status"></div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div id="loadingText">Processing image...</div>
            </div>

            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="info-box" id="infoBox" style="display: none;">
                <h3>üìä Image Info</h3>
                <div class="info-item">
                    <span class="info-label">Original Size:</span>
                    <span class="info-value" id="originalSize">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Grid Size:</span>
                    <span class="info-value" id="gridSize">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Pixels:</span>
                    <span class="info-value" id="pixelCount">-</span>
                </div>
            </div>

            <div class="control-group" id="gridSizeControl" style="display: none;">
                <label for="gridSizeSlider">Grid Size: <span id="gridSizeValue">32</span>x<span id="gridSizeValue2">32</span></label>
                <input type="range" id="gridSizeSlider" min="8" max="1024" step="8" value="32">
                <button class="btn-secondary" id="matchImageSize" style="margin-top: 5px;">
                    Match Image Size
                </button>
            </div>

            <div class="control-group" id="iterationsControl" style="display: none;">
                <label for="iterationsSlider">Max Iterations: <span id="iterationsValue">100</span></label>
                <input type="range" id="iterationsSlider" min="10" max="10000" step="50" value="100">
            </div>

            <div class="control-group">
                <button class="btn-primary" id="runPLAS" disabled>
                    ‚ñ∂Ô∏è Run PLAS Algorithm
                </button>
                <button class="btn-secondary" id="resetImage" disabled>
                    üîÑ Reset to Original
                </button>
            </div>

            <div class="metrics-grid" id="metricsBox" style="display: none;">
                <div class="metric-card">
                    <div class="metric-value" id="iterationCount">0</div>
                    <div class="metric-label">Iterations</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="smoothness">0.00</div>
                    <div class="metric-label">Smoothness Score</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="timeElapsed">0ms</div>
                    <div class="metric-label">Processing Time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="improvement">0%</div>
                    <div class="metric-label">Improvement</div>
                </div>
            </div>

            <div class="instructions">
                <h4>üìñ About PLAS</h4>
                <ul>
                    <li>PLAS sorts multi-dimensional data into locally smooth 2D grids</li>
                    <li>Minimizes L¬≤ distance between neighboring pixels</li>
                    <li>Created for Self-Organizing Gaussian Grids research</li>
                    <li>Upload any image or use the sample</li>
                    <li>Grid sizes: 8√ó8 up to 1024√ó1024</li>
                    <li>Iterations: 10 up to 10,000</li>
                    <li>Use "Match Image Size" for full resolution</li>
                    <li>Watch as pixels reorganize for local smoothness</li>
                </ul>
            </div>
        </div>

        <div class="viewer-panel panel">
            <div class="image-container">
                <div class="image-section">
                    <h3>üì• Original Image</h3>
                    <div class="canvas-wrapper">
                        <canvas id="originalCanvas"></canvas>
                    </div>
                </div>
                <div class="image-section">
                    <h3>üì§ PLAS Sorted Grid</h3>
                    <div class="canvas-wrapper">
                        <canvas id="sortedCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let originalImageData = null;
        let currentImageData = null;
        let gridSize = 32;
        let maxIterations = 100;

        const originalCanvas = document.getElementById('originalCanvas');
        const sortedCanvas = document.getElementById('sortedCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const sortedCtx = sortedCanvas.getContext('2d');

        // PLAS Algorithm Implementation
        class PLASsorter {
            constructor(imageData, gridSize) {
                this.gridSize = gridSize;
                this.data = this.prepareData(imageData, gridSize);
                this.width = gridSize;
                this.height = gridSize;
            }

            prepareData(imageData, gridSize) {
                // Resize image to grid size and extract RGB values
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = gridSize;
                tempCanvas.height = gridSize;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw resized image
                tempCtx.drawImage(
                    this.imageDataToCanvas(imageData),
                    0, 0, gridSize, gridSize
                );

                const resizedData = tempCtx.getImageData(0, 0, gridSize, gridSize);

                // Create 3D array (C, n, n) where C=3 for RGB
                const grid = [];
                for (let i = 0; i < gridSize * gridSize; i++) {
                    const idx = i * 4;
                    grid.push({
                        r: resizedData.data[idx],
                        g: resizedData.data[idx + 1],
                        b: resizedData.data[idx + 2],
                        originalIndex: i
                    });
                }

                return grid;
            }

            imageDataToCanvas(imageData) {
                const canvas = document.createElement('canvas');
                canvas.width = imageData.width;
                canvas.height = imageData.height;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }

            // Calculate L2 distance between two RGB colors
            colorDistance(c1, c2) {
                const dr = c1.r - c2.r;
                const dg = c1.g - c2.g;
                const db = c1.b - c2.b;
                return Math.sqrt(dr * dr + dg * dg + db * db);
            }

            // Calculate total smoothness cost (lower is better)
            calculateCost() {
                let cost = 0;
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const idx = y * this.width + x;
                        const pixel = this.data[idx];

                        // Check right neighbor
                        if (x < this.width - 1) {
                            const rightIdx = y * this.width + (x + 1);
                            cost += this.colorDistance(pixel, this.data[rightIdx]);
                        }

                        // Check bottom neighbor
                        if (y < this.height - 1) {
                            const bottomIdx = (y + 1) * this.width + x;
                            cost += this.colorDistance(pixel, this.data[bottomIdx]);
                        }
                    }
                }
                return cost;
            }

            // Find best position for a pixel to minimize local cost
            findBestPosition(pixelIdx) {
                const pixel = this.data[pixelIdx];
                let bestIdx = pixelIdx;
                let bestCost = this.calculateLocalCost(pixelIdx);

                // Try swapping with random positions
                const numTries = Math.min(20, this.data.length);
                for (let i = 0; i < numTries; i++) {
                    const randomIdx = Math.floor(Math.random() * this.data.length);

                    // Swap
                    [this.data[pixelIdx], this.data[randomIdx]] =
                        [this.data[randomIdx], this.data[pixelIdx]];

                    const newCost = this.calculateLocalCost(randomIdx);

                    if (newCost < bestCost) {
                        bestCost = newCost;
                        bestIdx = randomIdx;
                    }

                    // Swap back
                    [this.data[pixelIdx], this.data[randomIdx]] =
                        [this.data[randomIdx], this.data[pixelIdx]];
                }

                return bestIdx;
            }

            // Calculate cost for a specific position and its neighbors
            calculateLocalCost(idx) {
                let cost = 0;
                const x = idx % this.width;
                const y = Math.floor(idx / this.width);
                const pixel = this.data[idx];

                // Check all four neighbors
                if (x > 0) {
                    cost += this.colorDistance(pixel, this.data[idx - 1]);
                }
                if (x < this.width - 1) {
                    cost += this.colorDistance(pixel, this.data[idx + 1]);
                }
                if (y > 0) {
                    cost += this.colorDistance(pixel, this.data[idx - this.width]);
                }
                if (y < this.height - 1) {
                    cost += this.colorDistance(pixel, this.data[idx + this.width]);
                }

                return cost;
            }

            // Main sorting algorithm
            async sort(maxIterations, progressCallback) {
                const startCost = this.calculateCost();
                let currentCost = startCost;

                for (let iter = 0; iter < maxIterations; iter++) {
                    let improved = false;

                    // Create random order for processing pixels
                    const indices = Array.from({ length: this.data.length }, (_, i) => i);
                    this.shuffleArray(indices);

                    // Try to improve each pixel position
                    for (let i = 0; i < indices.length; i++) {
                        const idx = indices[i];
                        const currentLocalCost = this.calculateLocalCost(idx);

                        // Try to find better position
                        for (let j = i + 1; j < Math.min(i + 10, indices.length); j++) {
                            const swapIdx = indices[j];

                            // Calculate cost before swap
                            const costBefore = currentLocalCost + this.calculateLocalCost(swapIdx);

                            // Swap
                            [this.data[idx], this.data[swapIdx]] =
                                [this.data[swapIdx], this.data[idx]];

                            // Calculate cost after swap
                            const costAfter = this.calculateLocalCost(idx) + this.calculateLocalCost(swapIdx);

                            if (costAfter < costBefore) {
                                improved = true;
                            } else {
                                // Swap back if no improvement
                                [this.data[idx], this.data[swapIdx]] =
                                    [this.data[swapIdx], this.data[idx]];
                            }
                        }
                    }

                    // Update progress
                    const newCost = this.calculateCost();
                    const progress = ((iter + 1) / maxIterations) * 100;

                    if (progressCallback) {
                        await progressCallback({
                            iteration: iter + 1,
                            progress: progress,
                            cost: newCost,
                            improvement: ((startCost - newCost) / startCost) * 100
                        });
                    }

                    // Early stopping if no improvement
                    if (!improved && iter > 10) {
                        console.log(`Converged at iteration ${iter + 1}`);
                        break;
                    }

                    currentCost = newCost;

                    // Allow UI to update
                    if (iter % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                const finalCost = this.calculateCost();
                return {
                    startCost,
                    finalCost,
                    improvement: ((startCost - finalCost) / startCost) * 100
                };
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            // Convert sorted data back to ImageData
            toImageData() {
                const imageData = new ImageData(this.width, this.height);

                for (let i = 0; i < this.data.length; i++) {
                    const pixel = this.data[i];
                    const idx = i * 4;

                    imageData.data[idx] = pixel.r;
                    imageData.data[idx + 1] = pixel.g;
                    imageData.data[idx + 2] = pixel.b;
                    imageData.data[idx + 3] = 255;
                }

                return imageData;
            }
        }

        // Load image from file
        function loadImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Draw to canvas to get ImageData
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        const imageData = ctx.getImageData(0, 0, img.width, img.height);
                        resolve(imageData);
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Create sample gradient image
        function createSampleImage() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Create colorful gradient pattern
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const r = (x / size) * 255;
                    const g = (y / size) * 255;
                    const b = ((x + y) / (2 * size)) * 255;

                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }

            // Shuffle pixels randomly to make it interesting
            const imageData = ctx.getImageData(0, 0, size, size);
            const pixels = [];

            for (let i = 0; i < size * size; i++) {
                const idx = i * 4;
                pixels.push({
                    r: imageData.data[idx],
                    g: imageData.data[idx + 1],
                    b: imageData.data[idx + 2]
                });
            }

            // Shuffle
            for (let i = pixels.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pixels[i], pixels[j]] = [pixels[j], pixels[i]];
            }

            // Put back
            for (let i = 0; i < pixels.length; i++) {
                const idx = i * 4;
                imageData.data[idx] = pixels[i].r;
                imageData.data[idx + 1] = pixels[i].g;
                imageData.data[idx + 2] = pixels[i].b;
            }

            return imageData;
        }

        // Display image on canvas
        function displayImage(imageData, canvas) {
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(imageData, 0, 0);
        }

        // Show status message
        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status ${type}`;
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        }

        // Update info box
        function updateInfo(imageData, gridSize) {
            document.getElementById('originalSize').textContent =
                `${imageData.width}x${imageData.height}`;
            document.getElementById('gridSize').textContent =
                `${gridSize}x${gridSize}`;
            document.getElementById('pixelCount').textContent =
                (gridSize * gridSize).toLocaleString();
            document.getElementById('infoBox').style.display = 'block';
        }

        // Event handlers
        document.getElementById('imageFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                showStatus('Loading image...', 'info');
                originalImageData = await loadImage(file);
                currentImageData = null;

                displayImage(originalImageData, originalCanvas);
                sortedCtx.clearRect(0, 0, sortedCanvas.width, sortedCanvas.height);

                updateInfo(originalImageData, gridSize);
                showStatus('‚úì Image loaded successfully!', 'success');

                document.getElementById('runPLAS').disabled = false;
                document.getElementById('resetImage').disabled = false;
                document.getElementById('gridSizeControl').style.display = 'block';
                document.getElementById('iterationsControl').style.display = 'block';
            } catch (error) {
                console.error(error);
                showStatus(`‚úó Error: ${error.message}`, 'error');
            }
        });

        document.getElementById('loadSample').addEventListener('click', () => {
            try {
                showStatus('Creating sample image...', 'info');
                originalImageData = createSampleImage();
                currentImageData = null;

                displayImage(originalImageData, originalCanvas);
                sortedCtx.clearRect(0, 0, sortedCanvas.width, sortedCanvas.height);

                updateInfo(originalImageData, gridSize);
                showStatus('‚úì Sample image loaded!', 'success');

                document.getElementById('runPLAS').disabled = false;
                document.getElementById('resetImage').disabled = false;
                document.getElementById('gridSizeControl').style.display = 'block';
                document.getElementById('iterationsControl').style.display = 'block';
            } catch (error) {
                console.error(error);
                showStatus(`‚úó Error: ${error.message}`, 'error');
            }
        });

        document.getElementById('runPLAS').addEventListener('click', async () => {
            if (!originalImageData) return;

            try {
                const startTime = performance.now();

                document.getElementById('loading').style.display = 'block';
                document.getElementById('progressBar').style.display = 'block';
                document.getElementById('runPLAS').disabled = true;
                showStatus('Running PLAS algorithm...', 'info');

                const sorter = new PLASsorter(originalImageData, gridSize);

                let lastIteration = 0;
                const result = await sorter.sort(maxIterations, async (progress) => {
                    lastIteration = progress.iteration;
                    document.getElementById('progressFill').style.width = `${progress.progress}%`;
                    document.getElementById('loadingText').textContent =
                        `Iteration ${progress.iteration}/${maxIterations}...`;

                    // Update metrics
                    document.getElementById('iterationCount').textContent = progress.iteration;
                    document.getElementById('smoothness').textContent =
                        (1000000 / progress.cost).toFixed(2);
                    document.getElementById('improvement').textContent =
                        `${progress.improvement.toFixed(1)}%`;

                    // Update display periodically
                    if (progress.iteration % 10 === 0) {
                        const sortedImageData = sorter.toImageData();
                        displayImage(sortedImageData, sortedCanvas);
                    }
                });

                const endTime = performance.now();
                const timeElapsed = Math.round(endTime - startTime);

                currentImageData = sorter.toImageData();
                displayImage(currentImageData, sortedCanvas);

                // Update final metrics
                document.getElementById('iterationCount').textContent = lastIteration;
                document.getElementById('timeElapsed').textContent = `${timeElapsed}ms`;
                document.getElementById('improvement').textContent =
                    `${result.improvement.toFixed(1)}%`;
                document.getElementById('metricsBox').style.display = 'grid';

                showStatus(`‚úì PLAS completed in ${timeElapsed}ms!`, 'success');
            } catch (error) {
                console.error(error);
                showStatus(`‚úó Error: ${error.message}`, 'error');
            } finally {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('progressBar').style.display = 'none';
                document.getElementById('runPLAS').disabled = false;
            }
        });

        document.getElementById('resetImage').addEventListener('click', () => {
            if (!originalImageData) return;

            currentImageData = null;
            sortedCtx.clearRect(0, 0, sortedCanvas.width, sortedCanvas.height);
            document.getElementById('metricsBox').style.display = 'none';
            document.getElementById('progressFill').style.width = '0%';

            showStatus('‚úì Reset to original', 'success');
        });

        document.getElementById('gridSizeSlider').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('gridSizeValue').textContent = gridSize;
            document.getElementById('gridSizeValue2').textContent = gridSize;

            if (originalImageData) {
                updateInfo(originalImageData, gridSize);
            }
        });

        document.getElementById('matchImageSize').addEventListener('click', () => {
            if (!originalImageData) return;

            // Use the smaller dimension of the image, rounded to nearest multiple of 8
            const minDim = Math.min(originalImageData.width, originalImageData.height);
            const targetSize = Math.min(1024, Math.round(minDim / 8) * 8);

            gridSize = Math.max(8, targetSize);
            document.getElementById('gridSizeSlider').value = gridSize;
            document.getElementById('gridSizeValue').textContent = gridSize;
            document.getElementById('gridSizeValue2').textContent = gridSize;

            updateInfo(originalImageData, gridSize);
            showStatus(`Grid size set to ${gridSize}x${gridSize}`, 'success');
        });

        document.getElementById('iterationsSlider').addEventListener('input', (e) => {
            maxIterations = parseInt(e.target.value);
            document.getElementById('iterationsValue').textContent = maxIterations;
        });

        // Initialize
        showStatus('Ready to load image', 'info');
    </script>
</body>
</html>
