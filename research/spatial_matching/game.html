<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Corner Match-3</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            pointer-events: auto;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
        }
        
        #minimap table {
            border-collapse: collapse;
            font-size: 10px;
            font-family: monospace;
        }
        
        #minimap td {
            width: 20px;
            height: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-weight: bold;
            text-shadow: 0 0 2px black, 0 0 2px black;
        }
        
        #minimap .empty {
            background: rgba(50, 50, 50, 0.5);
        }
        
        #minimap .label {
            color: #aaa;
            font-size: 9px;
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #instructions {
            font-size: 12px;
            margin-top: 10px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="status">Ready to play!</div>
        <div id="instructions">
            Click a cube to select<br>
            Click another to swap<br>
            Match 3+ to score!
        </div>
        <div style="margin-top: 10px;">
            <label style="cursor: pointer;">
                <input type="checkbox" id="diagonalToggle" style="cursor: pointer;">
                Allow diagonal matches
            </label>
        </div>
    </div>
    <div id="minimap">
        <div class="label" style="text-align: center; margin-bottom: 5px;">Grid Layout</div>
        <table>
            <tr>
                <td id="cell-0-0">0</td><td id="cell-0-1">1</td><td id="cell-0-2">2</td><td id="cell-0-3">3</td><td id="cell-0-4">4</td>
                <td id="cell-0-5">5</td><td id="cell-0-6">6</td><td id="cell-0-7">7</td><td id="cell-0-8">8</td><td id="cell-0-9">9</td>
            </tr>
            <tr>
                <td id="cell-1-0">10</td><td id="cell-1-1">11</td><td id="cell-1-2">12</td><td id="cell-1-3">13</td><td id="cell-1-4">14</td>
                <td id="cell-1-5">15</td><td id="cell-1-6">16</td><td id="cell-1-7">17</td><td id="cell-1-8">18</td><td id="cell-1-9">19</td>
            </tr>
            <tr>
                <td id="cell-2-0">20</td><td id="cell-2-1">21</td><td id="cell-2-2">22</td><td id="cell-2-3">23</td><td id="cell-2-4">24</td>
                <td id="cell-2-5">25</td><td id="cell-2-6">26</td><td id="cell-2-7">27</td><td id="cell-2-8">28</td><td id="cell-2-9">29</td>
            </tr>
            <tr>
                <td id="cell-3-0">30</td><td id="cell-3-1">31</td><td id="cell-3-2">32</td><td id="cell-3-3">33</td><td id="cell-3-4">34</td>
                <td id="cell-3-5">35</td><td id="cell-3-6">36</td><td id="cell-3-7">37</td><td id="cell-3-8">38</td><td id="cell-3-9">39</td>
            </tr>
            <tr>
                <td id="cell-4-0">40</td><td id="cell-4-1">41</td><td id="cell-4-2">42</td><td id="cell-4-3">43</td><td id="cell-4-4">44</td>
                <td id="cell-4-5">45</td><td id="cell-4-6">46</td><td id="cell-4-7">47</td><td id="cell-4-8">48</td><td id="cell-4-9">49</td>
            </tr>
            <tr>
                <td id="cell-5-0">50</td><td id="cell-5-1">51</td><td id="cell-5-2">52</td><td id="cell-5-3">53</td><td id="cell-5-4">54</td>
                <td id="cell-5-5" class="empty">55</td><td id="cell-5-6" class="empty">56</td><td id="cell-5-7" class="empty">57</td><td id="cell-5-8" class="empty">58</td><td id="cell-5-9" class="empty">59</td>
            </tr>
            <tr>
                <td id="cell-6-0">60</td><td id="cell-6-1">61</td><td id="cell-6-2">62</td><td id="cell-6-3">63</td><td id="cell-6-4">64</td>
                <td id="cell-6-5" class="empty">65</td><td id="cell-6-6" class="empty">66</td><td id="cell-6-7" class="empty">67</td><td id="cell-6-8" class="empty">68</td><td id="cell-6-9" class="empty">69</td>
            </tr>
            <tr>
                <td id="cell-7-0">70</td><td id="cell-7-1">71</td><td id="cell-7-2">72</td><td id="cell-7-3">73</td><td id="cell-7-4">74</td>
                <td id="cell-7-5" class="empty">75</td><td id="cell-7-6" class="empty">76</td><td id="cell-7-7" class="empty">77</td><td id="cell-7-8" class="empty">78</td><td id="cell-7-9" class="empty">79</td>
            </tr>
            <tr>
                <td id="cell-8-0">80</td><td id="cell-8-1">81</td><td id="cell-8-2">82</td><td id="cell-8-3">83</td><td id="cell-8-4">84</td>
                <td id="cell-8-5" class="empty">85</td><td id="cell-8-6" class="empty">86</td><td id="cell-8-7" class="empty">87</td><td id="cell-8-8" class="empty">88</td><td id="cell-8-9" class="empty">89</td>
            </tr>
            <tr>
                <td id="cell-9-0">90</td><td id="cell-9-1">91</td><td id="cell-9-2">92</td><td id="cell-9-3">93</td><td id="cell-9-4">94</td>
                <td id="cell-9-5" class="empty">95</td><td id="cell-9-6" class="empty">96</td><td id="cell-9-7" class="empty">97</td><td id="cell-9-8" class="empty">98</td><td id="cell-9-9" class="empty">99</td>
            </tr>
        </table>
        <div class="label" style="margin-top: 5px; font-size: 8px;">
            Red: Back Wall | Green: Right Wall<br>
            Blue: Floor | Gray: Unused
        </div>
    </div>
    <div id="gameCanvas"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Constants
        const COLORS = [
            0xff0000, // red
            0x00ff00, // green
            0x0000ff, // blue
            0xffff00, // yellow
            0xff00ff  // magenta
        ];
        
        const BOARD_SIZE = 10;
        const SECTION_SIZE = 5;
        const CUBE_SIZE = 0.85;
        const SPACING = 1.0;
        
        // Game State
        let board = [];
        let cubes = [];
        let scene, camera, renderer, raycaster, mouse;
        let selectedCube = null;
        let score = 0;
        let isAnimating = false;
        let allowDiagonals = false; // Toggle for diagonal matching
        
        // Initialize
        function init() {
            setupScene();
            initBoard();
            createCubes();
            updateMinimap();
            animate();
            
            // Event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onWindowResize);
            
            // Diagonal toggle
            const diagonalToggle = document.getElementById('diagonalToggle');
            diagonalToggle.addEventListener('change', (e) => {
                allowDiagonals = e.target.checked;
                updateStatus(allowDiagonals ? 'Diagonal matches enabled' : 'Diagonal matches disabled');
            });
        }
        
        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera - positioned to see the corner clearly from outside
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('gameCanvas').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight1.position.set(5, 10, 5);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);

            // Raycaster for mouse picking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        function updateCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            const lookAtPoint = new THREE.Vector3(2.5, 2.5, 2.5);

            // Base camera position
            let baseDistance = 7;
            let xOffset = -5;
            let yOffset = 5;

            // For portrait/tall aspect ratios, move camera further back
            // to ensure the full width of the board is visible
            if (aspect < 1.0) {
                // Portrait mode - need more distance to see full width
                const extraDistance = (1.0 - aspect) * 8;
                baseDistance += extraDistance;
                xOffset -= extraDistance * 0.4;
                yOffset += extraDistance * 0.2;
            } else if (aspect < 1.3) {
                // Slightly tall - minor adjustment
                const extraDistance = (1.3 - aspect) * 3;
                baseDistance += extraDistance;
                xOffset -= extraDistance * 0.3;
            }

            camera.position.set(xOffset, yOffset, baseDistance);
            camera.lookAt(lookAtPoint);
        }
        
        function initBoard() {
            // Initialize 10x10 board with random colors
            board = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                board[row] = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Gray section is -1 (empty/unused)
                    if (row >= 5 && col >= 5) {
                        board[row][col] = -1;
                    } else {
                        board[row][col] = Math.floor(Math.random() * COLORS.length);
                    }
                }
            }
            
            // Clear initial matches
            while (findAndClearMatches()) {
                refillBoard();
            }
        }
        
        function createCubes() {
            cubes = [];
            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                cubes[row] = [];
                if (!board[row]) board[row] = [];
                
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === -1 || board[row][col] === undefined) {
                        cubes[row][col] = null;
                        continue;
                    }
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: COLORS[board[row][col]],
                        shininess: 30
                    });
                    
                    const cube = new THREE.Mesh(geometry, material);
                    cube.userData = { row, col };
                    
                    // Position based on section
                    const pos = getCubePosition(row, col);
                    cube.position.set(pos.x, pos.y, pos.z);
                    
                    scene.add(cube);
                    cubes[row][col] = cube;
                }
            }
        }
        
        function getCubePosition(row, col) {
            // Red section: rows 0-4, cols 0-4 (back wall - vertical)
            if (row < 5 && col < 5) {
                return {
                    x: col * SPACING,
                    y: (4 - row) * SPACING + 1,  // y=1 to y=5
                    z: 0                          // Back wall at z=0
                };
            }
            // Green section: rows 0-4, cols 5-9 (right wall - vertical)
            else if (row < 5 && col >= 5) {
                return {
                    x: SECTION_SIZE * SPACING,   // Right wall at x=5
                    y: (4 - row) * SPACING + 1,  // y=1 to y=5
                    z: (col - 5) * SPACING + 1   // z=1 to z=5 (in front of red wall)
                };
            }
            // Blue section: rows 5-9, cols 0-4 (floor - horizontal)
            else if (row >= 5 && col < 5) {
                return {
                    x: col * SPACING,              // x=0 to x=4 (matching Red columns)
                    y: 0,                          // Floor at y=0
                    z: (row - 5) * SPACING + 1     // z=1 to z=5 (in front of red wall)
                };
            }
            return { x: 0, y: 0, z: 0 };
        }
        
        function onMouseClick(event) {
            if (isAnimating) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const allCubes = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                if (!cubes[row]) continue;
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (cubes[row][col]) {
                        allCubes.push(cubes[row][col]);
                    }
                }
            }
            
            const intersects = raycaster.intersectObjects(allCubes);
            
            if (intersects.length > 0) {
                const clickedCube = intersects[0].object;
                
                if (!selectedCube) {
                    // Select first cube
                    selectedCube = clickedCube;
                    selectedCube.material.emissive.setHex(0x444444);
                    updateStatus('Selected! Click another cube to swap');
                } else if (selectedCube === clickedCube) {
                    // Deselect
                    selectedCube.material.emissive.setHex(0x000000);
                    selectedCube = null;
                    updateStatus('Deselected');
                } else {
                    // Swap
                    swapCubes(selectedCube, clickedCube);
                    selectedCube.material.emissive.setHex(0x000000);
                    selectedCube = null;
                }
            }
        }
        
        function swapCubes(cube1, cube2) {
            const row1 = cube1.userData.row;
            const col1 = cube1.userData.col;
            const row2 = cube2.userData.row;
            const col2 = cube2.userData.col;
            
            // Ensure arrays exist
            if (!board[row1]) board[row1] = [];
            if (!board[row2]) board[row2] = [];
            if (!cubes[row1]) cubes[row1] = [];
            if (!cubes[row2]) cubes[row2] = [];
            
            // Swap in board array
            const temp = board[row1][col1];
            board[row1][col1] = board[row2][col2];
            board[row2][col2] = temp;
            
            // Swap cube references
            cubes[row1][col1] = cube2;
            cubes[row2][col2] = cube1;
            
            // Update userData
            cube1.userData.row = row2;
            cube1.userData.col = col2;
            cube2.userData.row = row1;
            cube2.userData.col = col1;
            
            // Animate swap
            animateSwap(cube1, cube2, row1, col1, row2, col2);
        }
        
        function animateSwap(cube1, cube2, row1, col1, row2, col2) {
            isAnimating = true;
            
            const pos1 = getCubePosition(row2, col2);
            const pos2 = getCubePosition(row1, col1);
            
            const startTime = Date.now();
            const duration = 300;
            
            const start1 = cube1.position.clone();
            const start2 = cube2.position.clone();
            
            function animateStep() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                
                cube1.position.lerpVectors(start1, new THREE.Vector3(pos1.x, pos1.y, pos1.z), t);
                cube2.position.lerpVectors(start2, new THREE.Vector3(pos2.x, pos2.y, pos2.z), t);
                
                if (t < 1) {
                    requestAnimationFrame(animateStep);
                } else {
                    updateMinimap();
                    isAnimating = false;
                    checkForMatches();
                }
            }
            
            animateStep();
        }
        
        function checkForMatches() {
            if (findAndClearMatches()) {
                score += 10;
                updateScore();
                updateMinimap();
                setTimeout(() => {
                    applyGravity();
                }, 300);
            } else {
                updateStatus('No matches. Try again!');
            }
        }
        
        function findAndClearMatches() {
            const matches = new Set();
            
            // Check directions - conditionally include diagonals
            const directions = [
                [0, 1],   // horizontal
                [1, 0],   // vertical
            ];
            
            // Add diagonals only if enabled
            if (allowDiagonals) {
                directions.push([1, 1]);   // diagonal down-right
                directions.push([1, -1]);  // diagonal down-left
            }
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                if (!board[row]) continue;
                
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col] === -1 || board[row][col] === undefined) continue;
                    
                    const color = board[row][col];
                    
                    for (const [dr, dc] of directions) {
                        const matched = [[row, col]];
                        let r = row + dr;
                        let c = col + dc;
                        
                        while (isValidPosition(r, c) && board[r] && board[r][c] === color) {
                            matched.push([r, c]);
                            r += dr;
                            c += dc;
                        }
                        
                        if (matched.length >= 3) {
                            matched.forEach(([mr, mc]) => {
                                matches.add(`${mr},${mc}`);
                            });
                        }
                    }
                }
            }
            
            // Clear matches
            if (matches.size > 0) {
                matches.forEach(key => {
                    const [row, col] = key.split(',').map(Number);
                    if (board[row]) {
                        board[row][col] = -1;
                    }
                    if (cubes[row] && cubes[row][col]) {
                        scene.remove(cubes[row][col]);
                        cubes[row][col] = null;
                    }
                });
                return true;
            }
            
            return false;
        }
        
        function isValidPosition(row, col) {
            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) {
                return false;
            }
            // Gray section is invalid
            if (row >= 5 && col >= 5) {
                return false;
            }
            return true;
        }
        
        function applyGravity() {
            isAnimating = true;

            // Apply gravity iteratively until stable
            for (let iteration = 0; iteration < 50; iteration++) {
                let anyMoved = false;

                // Step 1: Within each section, move pieces down one step
                anyMoved = applyGravityStep() || anyMoved;

                // If nothing moved this iteration, we're done
                if (!anyMoved) break;
            }

            // Spawn new pieces at top of walls
            spawnNewPieces();

            // Update cube positions
            setTimeout(() => {
                updateAllCubePositions();
                updateMinimap();
                isAnimating = false;

                // Check for cascade matches
                if (findAndClearMatches()) {
                    score += 20; // Bonus for cascade
                    updateScore();
                    setTimeout(() => applyGravity(), 300);
                } else {
                    updateStatus('Ready to play!');
                }
            }, 500);
        }

        function applyGravityStep() {
            let moved = false;

            // Process from bottom to top to avoid moving pieces multiple times
            for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Skip empty cells and invalid cells
                    if (!board[row] || board[row][col] === -1 || board[row][col] === undefined) continue;
                    if (row >= 5 && col >= 5) continue; // Gray section

                    const piece = board[row][col];
                    let targetRow = -1;
                    let targetCol = -1;

                    // Determine where this piece wants to move
                    if (row < 5 && col < 5) {
                        // Red wall (back wall) - pieces fall down within the wall
                        if (row < 4) {
                            targetRow = row + 1;
                            targetCol = col;
                        } else if (row === 4) {
                            // Bottom of red wall - transfer to blue floor
                            targetRow = 5;
                            targetCol = col;
                        }
                    } else if (row < 5 && col >= 5) {
                        // Green wall (right wall) - pieces fall down within the wall
                        if (row < 4) {
                            targetRow = row + 1;
                            targetCol = col;
                        } else if (row === 4) {
                            // Bottom of green wall - transfer to blue floor
                            // Map green column to blue floor position
                            targetRow = col; // Green col 5->row 5, col 6->row 6, etc.
                            targetCol = 4;   // Right edge of floor
                        }
                    } else if (row >= 5 && col < 5) {
                        // Blue floor - pieces fall down within the floor
                        if (row < 9) {
                            targetRow = row + 1;
                            targetCol = col;
                        }
                    }

                    // Try to move piece to target position if it's empty
                    if (targetRow >= 0 && targetCol >= 0) {
                        if (!board[targetRow]) board[targetRow] = [];

                        if (board[targetRow][targetCol] === -1 || board[targetRow][targetCol] === undefined) {
                            // Move the piece
                            board[targetRow][targetCol] = piece;
                            board[row][col] = -1;
                            moved = true;
                        }
                    }
                }
            }

            return moved;
        }

        function spawnNewPieces() {
            // Spawn at top of Red wall (row 0, cols 0-4)
            if (!board[0]) board[0] = [];
            for (let col = 0; col < 5; col++) {
                if (board[0][col] === -1 || board[0][col] === undefined) {
                    board[0][col] = Math.floor(Math.random() * COLORS.length);
                }
            }
            
            // Spawn at top of Green wall (row 0, cols 5-9)
            for (let col = 5; col < 10; col++) {
                if (board[0][col] === -1 || board[0][col] === undefined) {
                    board[0][col] = Math.floor(Math.random() * COLORS.length);
                }
            }
        }
        
        function refillBoard() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                if (!board[row]) board[row] = [];
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (row >= 5 && col >= 5) continue;
                    if (board[row][col] === -1 || board[row][col] === undefined) {
                        board[row][col] = Math.floor(Math.random() * COLORS.length);
                    }
                }
            }
        }
        
        function updateAllCubePositions() {
            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
            
            for (let row = 0; row < BOARD_SIZE; row++) {
                if (!cubes[row]) {
                    cubes[row] = [];
                }
                
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Remove old cube if exists
                    if (cubes[row][col]) {
                        scene.remove(cubes[row][col]);
                        cubes[row][col] = null;
                    }
                    
                    // Create new cube if piece exists
                    if (board[row][col] !== -1) {
                        const material = new THREE.MeshPhongMaterial({
                            color: COLORS[board[row][col]],
                            shininess: 30
                        });
                        
                        const cube = new THREE.Mesh(geometry, material);
                        cube.userData = { row, col };
                        
                        const pos = getCubePosition(row, col);
                        cube.position.set(pos.x, pos.y, pos.z);
                        
                        scene.add(cube);
                        cubes[row][col] = cube;
                    }
                }
            }
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        function updateMinimap() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    if (!cell) continue;
                    
                    // Gray section stays empty
                    if (row >= 5 && col >= 5) {
                        continue;
                    }
                    
                    if (board[row] && board[row][col] !== -1 && board[row][col] !== undefined) {
                        const colorIndex = board[row][col];
                        const color = COLORS[colorIndex];
                        // Convert hex to rgb string
                        const r = (color >> 16) & 255;
                        const g = (color >> 8) & 255;
                        const b = color & 255;
                        cell.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                        cell.classList.remove('empty');
                    } else {
                        cell.style.backgroundColor = '';
                        cell.classList.add('empty');
                    }
                }
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>