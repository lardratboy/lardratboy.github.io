<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Vortex - Arcade Shooter</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
  <style>
    :root {
      --primary-color: #00D9FF;
      --secondary-color: #00FF41;
      --danger-color: #FF0055;
      --background-color: #000814;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background-color: var(--background-color);
      color: var(--secondary-color);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* UI Overlay */
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 18px;
      text-shadow: 0 0 10px var(--secondary-color);
      line-height: 1.6;
    }

    #wave-indicator {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      font-weight: bold;
      text-shadow: 0 0 15px var(--primary-color);
      color: var(--primary-color);
    }

    #combo-display {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 0 0 20px #FFD700;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #combo-display.visible {
      opacity: 1;
    }

    /* Screens */
    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center, #001428 0%, #000814 100%);
      pointer-events: all;
      z-index: 100;
    }

    .screen.active {
      display: flex;
    }

    #title-screen h1 {
      font-size: 72px;
      color: var(--primary-color);
      text-shadow: 0 0 30px var(--primary-color);
      margin-bottom: 40px;
      letter-spacing: 8px;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }

    .menu-text {
      font-size: 24px;
      margin: 10px 0;
      color: var(--secondary-color);
      text-shadow: 0 0 10px var(--secondary-color);
    }

    .blink {
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 50%, 100% { opacity: 1; }
      25%, 75% { opacity: 0.3; }
    }

    #game-over-screen h1,
    #victory-screen h1 {
      font-size: 64px;
      color: var(--danger-color);
      text-shadow: 0 0 30px var(--danger-color);
      margin-bottom: 30px;
    }

    #victory-screen h1 {
      color: #FFD700;
      text-shadow: 0 0 30px #FFD700;
    }

    .final-score {
      font-size: 36px;
      margin: 20px 0;
      color: var(--primary-color);
    }

    /* Instructions */
    .instructions {
      margin-top: 60px;
      text-align: center;
      line-height: 2;
      font-size: 16px;
      color: rgba(0, 255, 65, 0.7);
    }

    /* Wave Transition */
    #wave-transition {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: bold;
      color: var(--primary-color);
      text-shadow: 0 0 30px var(--primary-color);
      opacity: 0;
      pointer-events: none;
      z-index: 50;
      transition: opacity 0.3s;
    }

    #wave-transition.visible {
      opacity: 1;
    }

    /* Lives display */
    .life-icon {
      display: inline-block;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 16px solid var(--primary-color);
      margin-right: 8px;
      filter: drop-shadow(0 0 5px var(--primary-color));
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>

    <div id="ui-overlay">
      <!-- HUD -->
      <div id="hud">
        <div>SCORE: <span id="score-value">0</span></div>
        <div>LIVES: <span id="lives-display"></span></div>
        <div>HIGH: <span id="high-score-value">0</span></div>
      </div>

      <div id="wave-indicator">WAVE <span id="wave-number">1</span></div>
      <div id="combo-display"></div>
      <div id="wave-transition"></div>
    </div>

    <!-- Title Screen -->
    <div id="title-screen" class="screen active">
      <h1>SPACE VORTEX</h1>
      <div class="menu-text blink">PRESS SPACE TO START</div>
      <div class="instructions">
        <div>← → or A/D - MOVE</div>
        <div>SPACE or CLICK - FIRE</div>
        <div>P - PAUSE</div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen">
      <h1>GAME OVER</h1>
      <div class="final-score">FINAL SCORE: <span id="final-score-value">0</span></div>
      <div class="menu-text blink">PRESS SPACE TO RESTART</div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="screen">
      <h1>VICTORY!</h1>
      <div class="final-score">FINAL SCORE: <span id="victory-score-value">0</span></div>
      <div class="menu-text">YOU SURVIVED ALL WAVES!</div>
      <div class="menu-text blink">PRESS SPACE TO PLAY AGAIN</div>
    </div>
  </div>

  <script>
    // ==================== PATTERN GENERATOR ====================
    class PatternGenerator {
      static spiral(time, radius, spiralRate, angularVelocity, baseAngle = 0) {
        const r = radius + spiralRate * time;
        const angle = baseAngle + angularVelocity * time;
        return {
          x: r * Math.cos(angle),
          y: r * Math.sin(angle)
        };
      }

      static circle(time, radius, angularVelocity, baseAngle = 0) {
        const angle = baseAngle + angularVelocity * time;
        return {
          x: radius * Math.cos(angle),
          y: radius * Math.sin(angle)
        };
      }

      static lissajous(time, A, B, a, b, delta = 0) {
        return {
          x: A * Math.sin(a * time + delta),
          y: B * Math.sin(b * time)
        };
      }

      static wave(time, amplitude, frequency, speed, offset = 0) {
        return {
          x: offset,
          y: amplitude * Math.sin(frequency * time + speed * time)
        };
      }

      static epitrochoid(time, R, r, d) {
        const t = time;
        return {
          x: (R + r) * Math.cos(t) - d * Math.cos((R + r) / r * t),
          y: (R + r) * Math.sin(t) - d * Math.sin((R + r) / r * t)
        };
      }
    }

    // ==================== PARTICLE EFFECT ====================
    class ParticleEffect {
      constructor(scene, position, color, count = 20) {
        this.scene = scene;
        this.particles = [];
        this.lifetime = 1.0;
        this.age = 0;

        for (let i = 0; i < count; i++) {
          const geometry = new THREE.SphereGeometry(0.05, 4, 4);
          const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 1
          });
          const particle = new THREE.Mesh(geometry, material);

          particle.position.copy(position);

          const angle = (Math.PI * 2 * i) / count;
          const speed = 1 + Math.random() * 2;
          particle.userData.velocity = new THREE.Vector3(
            Math.cos(angle) * speed,
            Math.sin(angle) * speed,
            (Math.random() - 0.5) * 0.5
          );

          this.scene.add(particle);
          this.particles.push(particle);
        }
      }

      update(delta) {
        this.age += delta;
        const progress = this.age / this.lifetime;

        this.particles.forEach(particle => {
          particle.position.x += particle.userData.velocity.x * delta;
          particle.position.y += particle.userData.velocity.y * delta;
          particle.position.z += particle.userData.velocity.z * delta;

          particle.material.opacity = 1 - progress;
          particle.scale.setScalar(1 - progress * 0.5);
        });

        return this.age >= this.lifetime;
      }

      dispose() {
        this.particles.forEach(particle => {
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
        });
        this.particles = [];
      }
    }

    // ==================== PROJECTILE ====================
    class Projectile {
      constructor(scene, position, velocity, color, isPlayerProjectile = true) {
        this.scene = scene;
        this.isPlayerProjectile = isPlayerProjectile;

        const geometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
        const material = new THREE.MeshBasicMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 1
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(position);
        this.mesh.rotation.z = Math.PI / 2;

        this.velocity = velocity.clone();
        this.active = true;

        scene.add(this.mesh);

        // Add glow effect
        const glowGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.3
        });
        this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
        this.mesh.add(this.glow);
      }

      update(delta) {
        if (!this.active) return;

        this.mesh.position.x += this.velocity.x * delta;
        this.mesh.position.y += this.velocity.y * delta;
        this.mesh.position.z += this.velocity.z * delta;

        // Deactivate if off screen
        if (Math.abs(this.mesh.position.x) > 15 ||
            Math.abs(this.mesh.position.y) > 15 ||
            Math.abs(this.mesh.position.z) > 20) {
          this.active = false;
        }
      }

      dispose() {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.glow.geometry.dispose();
        this.glow.material.dispose();
      }
    }

    // ==================== PLAYER ====================
    class Player {
      constructor(scene) {
        this.scene = scene;
        this.lives = 3;
        this.speed = 8;
        this.fireRate = 0.15;
        this.lastFireTime = 0;
        this.bounds = { x: 6 };

        // Create player ship (wedge/triangle)
        const shipGeometry = new THREE.ConeGeometry(0.3, 0.6, 3);
        const shipMaterial = new THREE.MeshPhongMaterial({
          color: 0x00D9FF,
          emissive: 0x00D9FF,
          emissiveIntensity: 0.5,
          shininess: 100
        });

        this.mesh = new THREE.Mesh(shipGeometry, shipMaterial);
        this.mesh.rotation.x = -Math.PI / 2;
        this.mesh.rotation.z = Math.PI;
        this.mesh.position.set(0, -6, 0);

        scene.add(this.mesh);

        // Add engine glow
        const glowGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0x00D9FF,
          transparent: true,
          opacity: 0.3
        });
        this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
        this.mesh.add(this.glow);

        this.invulnerable = false;
        this.invulnerableTime = 0;
      }

      move(direction, delta) {
        this.mesh.position.x += direction * this.speed * delta;
        this.mesh.position.x = Math.max(-this.bounds.x, Math.min(this.bounds.x, this.mesh.position.x));
      }

      canFire(currentTime) {
        return currentTime - this.lastFireTime >= this.fireRate;
      }

      fire(currentTime) {
        if (!this.canFire(currentTime)) return null;

        this.lastFireTime = currentTime;
        const projectile = new Projectile(
          this.scene,
          new THREE.Vector3(this.mesh.position.x, this.mesh.position.y + 0.5, this.mesh.position.z),
          new THREE.Vector3(0, 15, 0),
          0xFFFFFF,
          true
        );
        return projectile;
      }

      hit() {
        if (this.invulnerable) return false;

        this.lives--;
        this.invulnerable = true;
        this.invulnerableTime = 2.0;
        return true;
      }

      update(delta) {
        if (this.invulnerable) {
          this.invulnerableTime -= delta;
          if (this.invulnerableTime <= 0) {
            this.invulnerable = false;
            this.mesh.material.opacity = 1;
          } else {
            this.mesh.material.opacity = (Math.sin(this.invulnerableTime * 20) + 1) / 2 * 0.5 + 0.5;
            this.mesh.material.transparent = true;
          }
        }
      }

      getPosition() {
        return this.mesh.position.clone();
      }

      dispose() {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
        this.glow.geometry.dispose();
        this.glow.material.dispose();
      }
    }

    // ==================== ENEMY ====================
    class Enemy {
      constructor(scene, type, formationPos, formationAngle = 0) {
        this.scene = scene;
        this.type = type;
        this.formationPos = formationPos.clone();
        this.formationAngle = formationAngle;
        this.active = true;
        this.inFormation = true;
        this.sortieStartTime = 0;
        this.sortiePattern = null;
        this.lastFireTime = 0;

        const config = this.getTypeConfig();
        this.health = config.health;
        this.maxHealth = config.health;
        this.speed = config.speed;
        this.score = config.score;
        this.color = config.color;
        this.fireRate = config.fireRate;

        // Create enemy mesh
        const geometry = config.geometry;
        const material = new THREE.MeshPhongMaterial({
          color: this.color,
          emissive: this.color,
          emissiveIntensity: 0.3,
          shininess: 100
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(formationPos);

        scene.add(this.mesh);
      }

      getTypeConfig() {
        const configs = {
          scout: {
            health: 1,
            speed: 1.5,
            score: 10,
            color: 0x00FFFF,
            fireRate: 2.0,
            geometry: new THREE.SphereGeometry(0.2, 8, 8)
          },
          fighter: {
            health: 2,
            speed: 2.0,
            score: 25,
            color: 0xFF00FF,
            fireRate: 1.5,
            geometry: new THREE.TetrahedronGeometry(0.25)
          },
          bomber: {
            health: 3,
            speed: 1.0,
            score: 50,
            color: 0xFFFF00,
            fireRate: 1.0,
            geometry: new THREE.OctahedronGeometry(0.3)
          },
          elite: {
            health: 4,
            speed: 1.8,
            score: 100,
            color: 0x00FF00,
            fireRate: 0.8,
            geometry: new THREE.IcosahedronGeometry(0.25)
          }
        };
        return configs[this.type] || configs.scout;
      }

      startSortie(pattern, currentTime) {
        this.inFormation = false;
        this.sortiePattern = pattern;
        this.sortieStartTime = currentTime;
        this.sortieOrigin = this.mesh.position.clone();
      }

      returnToFormation() {
        this.inFormation = true;
        this.sortiePattern = null;
      }

      update(delta, currentTime, playerPos, formationOffset) {
        if (this.inFormation) {
          // Follow formation position with offset
          const targetPos = this.formationPos.clone().add(formationOffset);
          this.mesh.position.lerp(targetPos, delta * 3);
        } else if (this.sortiePattern) {
          // Execute sortie pattern
          const t = (currentTime - this.sortieStartTime) * this.speed;
          let offset = { x: 0, y: 0 };

          switch (this.sortiePattern.type) {
            case 'dive':
              offset = {
                x: Math.sin(t * 2) * 2,
                y: -t * 3
              };
              break;
            case 'spiral':
              offset = PatternGenerator.spiral(t, 0.5, 0.3, 3, this.formationAngle);
              offset.y -= t * 1.5;
              break;
            case 'sweep':
              offset = {
                x: Math.sin(t) * 4,
                y: -t * 2
              };
              break;
            case 'circle':
              offset = PatternGenerator.circle(t, 2, 4, this.formationAngle);
              offset.y -= t * 0.5;
              break;
          }

          this.mesh.position.x = this.sortieOrigin.x + offset.x;
          this.mesh.position.y = this.sortieOrigin.y + offset.y;

          // Return to formation or exit if off screen
          if (this.mesh.position.y < -10 || Math.abs(this.mesh.position.x) > 10) {
            if (Math.random() < 0.3) {
              this.returnToFormation();
            } else {
              this.active = false;
            }
          }
        }

        // Rotate for visual effect
        this.mesh.rotation.y += delta * 2;
      }

      canFire(currentTime) {
        return currentTime - this.lastFireTime >= this.fireRate;
      }

      fire(currentTime, playerPos) {
        if (!this.canFire(currentTime)) return null;

        this.lastFireTime = currentTime;

        // Calculate direction to player
        const direction = new THREE.Vector3().subVectors(playerPos, this.mesh.position).normalize();

        const projectile = new Projectile(
          this.scene,
          this.mesh.position.clone(),
          direction.multiplyScalar(8),
          this.color,
          false
        );
        return projectile;
      }

      hit() {
        this.health--;

        // Flash effect
        this.mesh.material.emissiveIntensity = 1;
        setTimeout(() => {
          if (this.mesh.material) {
            this.mesh.material.emissiveIntensity = 0.3;
          }
        }, 100);

        return this.health <= 0;
      }

      getPosition() {
        return this.mesh.position.clone();
      }

      dispose() {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    // ==================== FORMATION ====================
    class Formation {
      constructor(scene, wave) {
        this.scene = scene;
        this.wave = wave;
        this.enemies = [];
        this.time = 0;
        this.centerPos = new THREE.Vector3(0, 8, 0);
        this.formationType = this.selectFormationType();
        this.spawnEnemies();
      }

      selectFormationType() {
        const types = ['circle', 'vee', 'grid', 'spiral'];
        return types[Math.floor(Math.random() * types.length)];
      }

      spawnEnemies() {
        const composition = this.getWaveComposition();
        let positions = this.generateFormationPositions(composition.total);
        let index = 0;

        // Spawn scouts
        for (let i = 0; i < composition.scouts; i++) {
          const enemy = new Enemy(this.scene, 'scout', positions[index], (index / positions.length) * Math.PI * 2);
          this.enemies.push(enemy);
          index++;
        }

        // Spawn fighters
        for (let i = 0; i < composition.fighters; i++) {
          const enemy = new Enemy(this.scene, 'fighter', positions[index], (index / positions.length) * Math.PI * 2);
          this.enemies.push(enemy);
          index++;
        }

        // Spawn bombers
        for (let i = 0; i < composition.bombers; i++) {
          const enemy = new Enemy(this.scene, 'bomber', positions[index], (index / positions.length) * Math.PI * 2);
          this.enemies.push(enemy);
          index++;
        }

        // Spawn elites
        for (let i = 0; i < composition.elites; i++) {
          const enemy = new Enemy(this.scene, 'elite', positions[index], (index / positions.length) * Math.PI * 2);
          this.enemies.push(enemy);
          index++;
        }
      }

      getWaveComposition() {
        const scouts = Math.min(5 + this.wave * 2, 20);
        const fighters = Math.min(Math.floor(this.wave / 2), 10);
        const bombers = Math.min(Math.floor(this.wave / 3), 6);
        const elites = Math.min(Math.floor(this.wave / 5), 4);

        return {
          scouts,
          fighters,
          bombers,
          elites,
          total: scouts + fighters + bombers + elites
        };
      }

      generateFormationPositions(count) {
        const positions = [];

        switch (this.formationType) {
          case 'circle':
            for (let i = 0; i < count; i++) {
              const angle = (Math.PI * 2 * i) / count;
              const radius = 3;
              positions.push(new THREE.Vector3(
                this.centerPos.x + Math.cos(angle) * radius,
                this.centerPos.y + Math.sin(angle) * radius,
                0
              ));
            }
            break;

          case 'vee':
            const rowSize = Math.ceil(Math.sqrt(count));
            for (let i = 0; i < count; i++) {
              const row = Math.floor(i / rowSize);
              const col = i % rowSize;
              const offsetX = (col - rowSize / 2) * 0.8 + row * 0.4;
              const offsetY = -row * 0.8;
              positions.push(new THREE.Vector3(
                this.centerPos.x + offsetX,
                this.centerPos.y + offsetY,
                0
              ));
            }
            break;

          case 'grid':
            const cols = Math.ceil(Math.sqrt(count));
            for (let i = 0; i < count; i++) {
              const row = Math.floor(i / cols);
              const col = i % cols;
              positions.push(new THREE.Vector3(
                this.centerPos.x + (col - cols / 2) * 0.8,
                this.centerPos.y - row * 0.8,
                0
              ));
            }
            break;

          case 'spiral':
            for (let i = 0; i < count; i++) {
              const angle = i * 0.5;
              const radius = 0.3 + i * 0.15;
              positions.push(new THREE.Vector3(
                this.centerPos.x + Math.cos(angle) * radius,
                this.centerPos.y + Math.sin(angle) * radius,
                0
              ));
            }
            break;
        }

        return positions;
      }

      update(delta, currentTime, playerPos) {
        this.time += delta;

        // Calculate formation offset based on pattern
        let formationOffset = new THREE.Vector3(0, 0, 0);

        switch (this.formationType) {
          case 'circle':
            formationOffset = PatternGenerator.circle(this.time * 0.5, 0, 0.3);
            formationOffset.y -= this.time * 0.2;
            break;
          case 'spiral':
            formationOffset = PatternGenerator.spiral(this.time * 0.3, 0, 0.05, 0.5);
            formationOffset.y -= this.time * 0.15;
            break;
          default:
            formationOffset.y = -this.time * 0.2;
        }

        // Update all enemies
        this.enemies.forEach(enemy => {
          enemy.update(delta, currentTime, playerPos, formationOffset);
        });

        // Randomly send enemies on sorties
        if (Math.random() < 0.01 * this.wave) {
          const availableEnemies = this.enemies.filter(e => e.active && e.inFormation);
          if (availableEnemies.length > 0) {
            const enemy = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
            const patterns = ['dive', 'spiral', 'sweep', 'circle'];
            const pattern = { type: patterns[Math.floor(Math.random() * patterns.length)] };
            enemy.startSortie(pattern, currentTime);
          }
        }

        // Remove inactive enemies
        this.enemies = this.enemies.filter(enemy => {
          if (!enemy.active) {
            enemy.dispose();
            return false;
          }
          return true;
        });
      }

      isEmpty() {
        return this.enemies.length === 0;
      }

      getEnemies() {
        return this.enemies;
      }

      dispose() {
        this.enemies.forEach(enemy => enemy.dispose());
        this.enemies = [];
      }
    }

    // ==================== GAME ====================
    class Game {
      constructor() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000814);

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0, 15);
        this.camera.lookAt(0, 0, 0);

        this.renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById('game-canvas'),
          antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);

        this.setupLighting();
        this.createStarField();

        this.state = 'title'; // title, playing, gameover, victory, paused
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem('spaceVortexHighScore') || '0');
        this.wave = 1;
        this.maxWaves = 20;
        this.comboCount = 0;
        this.comboTimer = null;

        this.player = null;
        this.formation = null;
        this.projectiles = [];
        this.particles = [];

        this.keys = {};
        this.mouseDown = false;

        this.clock = new THREE.Clock();
        this.currentTime = 0;

        this.setupEventListeners();
        this.updateUI();
        this.animate();
      }

      setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00D9FF, 1, 50);
        pointLight1.position.set(0, -5, 5);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xFF00FF, 0.8, 50);
        pointLight2.position.set(0, 5, 5);
        this.scene.add(pointLight2);
      }

      createStarField() {
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];

        for (let i = 0; i < 500; i++) {
          starVertices.push(
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 50,
            (Math.random() - 0.5) * 30 - 10
          );
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({
          color: 0xFFFFFF,
          size: 0.1,
          transparent: true,
          opacity: 0.8
        });

        this.stars = new THREE.Points(starGeometry, starMaterial);
        this.scene.add(this.stars);
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.onWindowResize());
        window.addEventListener('keydown', (e) => this.onKeyDown(e));
        window.addEventListener('keyup', (e) => this.onKeyUp(e));
        window.addEventListener('mousedown', () => this.mouseDown = true);
        window.addEventListener('mouseup', () => this.mouseDown = false);
      }

      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      onKeyDown(e) {
        this.keys[e.key.toLowerCase()] = true;

        if (e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();

          if (this.state === 'title') {
            this.startGame();
          } else if (this.state === 'gameover' || this.state === 'victory') {
            this.resetGame();
          } else if (this.state === 'playing' && this.player) {
            const projectile = this.player.fire(this.currentTime);
            if (projectile) this.projectiles.push(projectile);
          }
        }

        if (e.key === 'p' || e.key === 'P') {
          if (this.state === 'playing') {
            this.pauseGame();
          } else if (this.state === 'paused') {
            this.resumeGame();
          }
        }
      }

      onKeyUp(e) {
        this.keys[e.key.toLowerCase()] = false;
      }

      startGame() {
        this.state = 'playing';
        this.score = 0;
        this.wave = 1;
        this.comboCount = 0;

        this.player = new Player(this.scene);
        this.formation = new Formation(this.scene, this.wave);

        this.hideAllScreens();
        this.updateUI();

        this.showWaveTransition();
      }

      resetGame() {
        if (this.player) {
          this.player.dispose();
          this.player = null;
        }
        if (this.formation) {
          this.formation.dispose();
          this.formation = null;
        }
        this.projectiles.forEach(p => p.dispose());
        this.projectiles = [];
        this.particles.forEach(p => p.dispose());
        this.particles = [];

        this.startGame();
      }

      pauseGame() {
        this.state = 'paused';
        this.clock.stop();
      }

      resumeGame() {
        this.state = 'playing';
        this.clock.start();
      }

      nextWave() {
        this.wave++;

        if (this.wave > this.maxWaves) {
          this.victory();
          return;
        }

        if (this.formation) {
          this.formation.dispose();
        }

        this.formation = new Formation(this.scene, this.wave);
        this.showWaveTransition();
      }

      showWaveTransition() {
        const waveTransition = document.getElementById('wave-transition');
        waveTransition.textContent = `WAVE ${this.wave}`;
        waveTransition.classList.add('visible');

        setTimeout(() => {
          waveTransition.classList.remove('visible');
        }, 2000);
      }

      gameOver() {
        this.state = 'gameover';

        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('spaceVortexHighScore', this.highScore.toString());
        }

        document.getElementById('final-score-value').textContent = this.score;
        document.getElementById('game-over-screen').classList.add('active');
      }

      victory() {
        this.state = 'victory';

        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('spaceVortexHighScore', this.highScore.toString());
        }

        document.getElementById('victory-score-value').textContent = this.score;
        document.getElementById('victory-screen').classList.add('active');
      }

      hideAllScreens() {
        document.querySelectorAll('.screen').forEach(screen => {
          screen.classList.remove('active');
        });
      }

      updateUI() {
        document.getElementById('score-value').textContent = this.score;
        document.getElementById('high-score-value').textContent = this.highScore;
        document.getElementById('wave-number').textContent = this.wave;

        if (this.player) {
          const livesDisplay = document.getElementById('lives-display');
          livesDisplay.innerHTML = '';
          for (let i = 0; i < this.player.lives; i++) {
            const lifeIcon = document.createElement('span');
            lifeIcon.className = 'life-icon';
            livesDisplay.appendChild(lifeIcon);
          }
        }
      }

      updateComboDisplay() {
        const comboDisplay = document.getElementById('combo-display');
        if (this.comboCount > 1) {
          comboDisplay.textContent = `${this.comboCount}x COMBO!`;
          comboDisplay.classList.add('visible');
        } else {
          comboDisplay.classList.remove('visible');
        }
      }

      addScore(points) {
        // Reset combo timer
        if (this.comboTimer) {
          clearTimeout(this.comboTimer);
        }

        this.comboCount++;
        this.updateComboDisplay();

        this.comboTimer = setTimeout(() => {
          this.comboCount = 0;
          this.updateComboDisplay();
        }, 2000);

        // Apply combo multiplier
        const multiplier = 1 + (this.comboCount - 1) * 0.5;
        this.score += Math.floor(points * multiplier);
        this.updateUI();
      }

      update(delta) {
        if (this.state !== 'playing' || !this.player) return;

        this.currentTime += delta;

        // Update player
        let moveDirection = 0;
        if (this.keys['arrowleft'] || this.keys['a']) moveDirection -= 1;
        if (this.keys['arrowright'] || this.keys['d']) moveDirection += 1;

        if (moveDirection !== 0) {
          this.player.move(moveDirection, delta);
        }

        this.player.update(delta);

        // Auto-fire if mouse down
        if (this.mouseDown) {
          const projectile = this.player.fire(this.currentTime);
          if (projectile) this.projectiles.push(projectile);
        }

        // Update formation
        if (this.formation) {
          this.formation.update(delta, this.currentTime, this.player.getPosition());

          // Enemy firing
          this.formation.getEnemies().forEach(enemy => {
            if (!enemy.inFormation && Math.random() < 0.02) {
              const projectile = enemy.fire(this.currentTime, this.player.getPosition());
              if (projectile) this.projectiles.push(projectile);
            }
          });

          // Check if wave is complete
          if (this.formation.isEmpty()) {
            this.nextWave();
          }
        }

        // Update projectiles
        this.projectiles.forEach(p => p.update(delta));
        this.projectiles = this.projectiles.filter(p => {
          if (!p.active) {
            p.dispose();
            return false;
          }
          return true;
        });

        // Update particles
        this.particles = this.particles.filter(particle => {
          const expired = particle.update(delta);
          if (expired) {
            particle.dispose();
            return false;
          }
          return true;
        });

        // Collision detection
        this.checkCollisions();

        // Animate stars
        this.stars.position.y -= delta * 2;
        if (this.stars.position.y < -10) {
          this.stars.position.y = 0;
        }

        // Check game over
        if (this.player.lives <= 0) {
          this.gameOver();
        }
      }

      checkCollisions() {
        if (!this.player || !this.formation) return;

        const playerPos = this.player.getPosition();
        const playerRadius = 0.3;

        // Player projectiles vs enemies
        this.projectiles.filter(p => p.isPlayerProjectile && p.active).forEach(projectile => {
          this.formation.getEnemies().forEach(enemy => {
            const distance = projectile.mesh.position.distanceTo(enemy.getPosition());
            if (distance < 0.5) {
              projectile.active = false;
              const destroyed = enemy.hit();

              if (destroyed) {
                this.addScore(enemy.score);
                this.particles.push(new ParticleEffect(this.scene, enemy.getPosition(), enemy.color, 15));
                enemy.active = false;
              }
            }
          });
        });

        // Enemy projectiles vs player
        this.projectiles.filter(p => !p.isPlayerProjectile && p.active).forEach(projectile => {
          const distance = projectile.mesh.position.distanceTo(playerPos);
          if (distance < playerRadius + 0.2) {
            projectile.active = false;
            if (this.player.hit()) {
              this.particles.push(new ParticleEffect(this.scene, playerPos, 0x00D9FF, 20));
              this.updateUI();
            }
          }
        });

        // Enemies vs player (collision)
        this.formation.getEnemies().forEach(enemy => {
          const distance = enemy.getPosition().distanceTo(playerPos);
          if (distance < playerRadius + 0.3) {
            enemy.active = false;
            if (this.player.hit()) {
              this.particles.push(new ParticleEffect(this.scene, playerPos, 0x00D9FF, 20));
              this.updateUI();
            }
            this.particles.push(new ParticleEffect(this.scene, enemy.getPosition(), enemy.color, 15));
          }
        });
      }

      animate() {
        requestAnimationFrame(() => this.animate());

        const delta = this.clock.getDelta();

        TWEEN.update();
        this.update(delta);
        this.renderer.render(this.scene, this.camera);
      }
    }

    // Start the game
    window.addEventListener('DOMContentLoaded', () => {
      new Game();
    });
  </script>
</body>
</html>
