<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Crystal Connections: Energy Cascade</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.min.js"></script>
  <style>
    /* --- CSS Variables and Basic Reset --- */
    :root {
      --primary-color: #00ffff;
      --secondary-color: #ff00ff;
      --accent-color: #ffff00;
      --background-color: #0a0a1a;
      --light-text: #ffffff;
      --overlay-bg: rgba(10, 10, 26, 0.95);
      --win-overlay-bg: rgba(100, 20, 100, 0.9);
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: var(--background-color);
      color: var(--light-text);
      position: fixed;
      width: 100%;
      height: 100%;
    }

    /* --- Screen Management --- */
    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      box-sizing: border-box;
      background: radial-gradient(circle at center, #1a0a2e 0%, #0a0a1a 100%);
      transition: opacity 0.5s ease;
      opacity: 0;
    }

    .screen.active {
      display: flex;
      opacity: 1;
    }

    /* --- Splash Screen Styling --- */
    #splash-screen {
      background: radial-gradient(ellipse at top, #2d1b4e 0%, #1a0a2e 40%, #0a0a1a 100%);
      position: relative;
      overflow: hidden;
    }

    #splash-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(2px 2px at 20% 30%, white, transparent),
        radial-gradient(2px 2px at 60% 70%, white, transparent),
        radial-gradient(1px 1px at 50% 50%, white, transparent),
        radial-gradient(1px 1px at 80% 10%, white, transparent),
        radial-gradient(2px 2px at 90% 60%, white, transparent),
        radial-gradient(1px 1px at 33% 80%, white, transparent);
      background-size: 200% 200%;
      animation: stars 20s linear infinite;
      opacity: 0.3;
    }

    @keyframes stars {
      from { background-position: 0 0; }
      to { background-position: 100% 100%; }
    }

    #splash-3d-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }

    .splash-content {
      position: relative;
      z-index: 10;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      max-width: 500px;
    }

    .title-container {
      text-align: center;
      margin-bottom: 40px;
      position: relative;
      z-index: 10;
      width: 100%;
    }

    .splash-title {
      font-size: clamp(2.5rem, 10vw, 4.5rem);
      font-weight: 900;
      background: linear-gradient(135deg, #00ffff 0%, #ff00ff 50%, #ffff00 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow:
        0 0 20px rgba(0, 255, 255, 0.5),
        0 0 40px rgba(255, 0, 255, 0.3);
      letter-spacing: 0.05em;
      margin: 0;
      line-height: 0.9;
      filter: drop-shadow(4px 4px 0px rgba(0, 0, 0, 0.8));
    }

    .splash-subtitle {
      font-size: clamp(1rem, 4vw, 1.5rem);
      color: var(--primary-color);
      margin-top: 10px;
      margin-bottom: 0;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      font-weight: 600;
    }

    .menu-container {
      width: 100%;
      max-width: 380px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      position: relative;
      z-index: 10;
      margin: 0 auto;
    }

    .btn {
      padding: 18px 24px;
      border-radius: 15px;
      border: 4px solid #000000;
      color: #ffffff;
      cursor: pointer;
      font-size: 1.4rem;
      font-weight: 900;
      text-transform: uppercase;
      transition: transform 0.2s ease, box-shadow 0.3s ease;
      text-shadow: 2px 2px 0px #000000;
      letter-spacing: 0.1em;
      position: relative;
      overflow: hidden;
      pointer-events: all;
      width: 100%;
      max-width: 280px;
      text-align: center;
    }

    .btn:hover {
      transform: translateY(-3px) scale(1.05);
    }

    .btn:active {
      transform: scale(0.96) translateY(0);
    }

    .btn-primary {
      background: linear-gradient(135deg, #00ffff 0%, #00aaff 100%);
      box-shadow: 0 6px 0 #004466, 0 8px 15px rgba(0, 255, 255, 0.4);
    }

    .btn-primary:hover {
      box-shadow: 0 8px 0 #004466, 0 12px 20px rgba(0, 255, 255, 0.6);
    }

    .btn-secondary {
      background: linear-gradient(135deg, #ff00ff 0%, #aa00ff 100%);
      box-shadow: 0 6px 0 #440066, 0 8px 15px rgba(255, 0, 255, 0.4);
    }

    .btn-secondary:hover {
      box-shadow: 0 8px 0 #440066, 0 12px 20px rgba(255, 0, 255, 0.6);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ff0066 0%, #cc0044 100%);
      box-shadow: 0 6px 0 #660022, 0 8px 15px rgba(255, 0, 102, 0.4);
    }

    .btn-danger:hover {
      box-shadow: 0 8px 0 #660022, 0 12px 20px rgba(255, 0, 102, 0.6);
    }

    /* Floating particles */
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, #00ffff 0%, transparent 70%);
      border-radius: 50%;
      animation: float-particle 15s ease-in-out infinite;
      opacity: 0.6;
      pointer-events: none;
      z-index: 3;
    }

    .particle:nth-child(2n) {
      animation-duration: 12s;
      background: radial-gradient(circle, #ff00ff 0%, transparent 70%);
    }

    .particle:nth-child(3n) {
      animation-duration: 18s;
      background: radial-gradient(circle, #ffff00 0%, transparent 70%);
    }

    @keyframes float-particle {
      0%, 100% {
        transform: translate(0, 0) scale(1);
        opacity: 0.3;
      }
      25% {
        transform: translate(20px, -50px) scale(1.2);
        opacity: 0.6;
      }
      50% {
        transform: translate(-20px, -100px) scale(0.8);
        opacity: 0.4;
      }
      75% {
        transform: translate(30px, -150px) scale(1.1);
        opacity: 0.5;
      }
    }

    /* --- Settings Screen --- */
    #settings-screen .menu-container {
      background-color: rgba(10, 10, 26, 0.9);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
      border: 4px solid rgba(0, 255, 255, 0.5);
    }

    .setting-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .setting-item label {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--primary-color);
    }

    .setting-item select {
      padding: 10px;
      border-radius: 8px;
      border: 2px solid var(--primary-color);
      background-color: rgba(0, 0, 0, 0.5);
      color: var(--light-text);
      font-size: 1rem;
      font-weight: 600;
      width: 100px;
      text-align: center;
      cursor: pointer;
    }

    /* --- Game Screen & UI --- */
    #game-screen {
      padding: 0;
      cursor: default;
    }

    #container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #game-ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      pointer-events: none;
    }

    #game-menu-btn,
    #game-score,
    #combo-display {
      pointer-events: all;
      font-size: clamp(1.2rem, 5vw, 1.8rem);
      font-weight: bold;
      color: var(--light-text);
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px 18px;
      border-radius: 12px;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      transition: transform 0.2s ease;
      border: 2px solid rgba(0, 255, 255, 0.3);
    }

    #game-menu-btn:hover {
      transform: scale(1.05);
      cursor: pointer;
    }

    #combo-display {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(255, 0, 255, 0.8) 0%, rgba(255, 255, 0, 0.8) 100%);
      font-size: clamp(1.5rem, 6vw, 2.5rem);
      padding: 15px 30px;
      display: none;
      animation: pulse 0.5s ease-in-out infinite alternate;
    }

    #combo-display.visible {
      display: block;
    }

    @keyframes pulse {
      from { transform: translateX(-50%) scale(1); }
      to { transform: translateX(-50%) scale(1.1); }
    }

    /* --- Overlays --- */
    .overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      width: 90%;
      max-width: 400px;
      background-color: var(--overlay-bg);
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      z-index: 200;
      box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
      border: 3px solid var(--primary-color);
      display: none;
      opacity: 0;
      transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.3s ease;
    }

    .overlay.visible {
      display: block;
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    #gameWin {
      background: var(--win-overlay-bg);
      border-color: var(--secondary-color);
      box-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
    }

    .overlay h2 {
      margin-top: 0;
      font-size: clamp(1.8rem, 8vw, 2.5rem);
      background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .overlay p {
      font-size: clamp(1rem, 4vw, 1.2rem);
      margin: 20px 0;
    }

    .overlay .btn {
      margin-top: 10px;
      width: 100%;
    }

    /* Info panel */
    #info-panel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      border: 2px solid rgba(0, 255, 255, 0.3);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>

<body>
  <!-- SPLASH SCREEN -->
  <div id="splash-screen" class="screen active">
    <div id="splash-3d-container"></div>
    <div id="particles-container"></div>
    <div class="splash-content">
      <div class="title-container">
        <h1 class="splash-title">CRYSTAL<br>CONNECTIONS</h1>
        <h2 class="splash-subtitle">Energy Cascade</h2>
      </div>
      <div class="menu-container">
        <button id="start-game-btn" class="btn btn-primary">Start Game</button>
        <button id="settings-btn" class="btn btn-secondary">Settings</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS SCREEN -->
  <div id="settings-screen" class="screen">
    <h1 class="splash-title">Settings</h1>
    <div class="menu-container">
      <div class="setting-item">
        <label for="rows-setting">Grid Size</label>
        <select id="rows-setting">
          <option value="7">7x7</option>
          <option value="9" selected>9x9</option>
          <option value="11">11x11</option>
        </select>
      </div>
      <div class="setting-item">
        <label for="difficulty-setting">Difficulty</label>
        <select id="difficulty-setting">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </div>
      <button id="back-to-splash-btn" class="btn btn-danger">Back</button>
    </div>
  </div>

  <!-- GAME SCREEN -->
  <div id="game-screen" class="screen">
    <div id="container"></div>
    <div id="game-ui">
      <div id="game-menu-btn">☰</div>
      <div id="combo-display"></div>
      <div id="game-score">0</div>
    </div>
    <div id="info-panel">
      Match shapes to create combos • Charge all mega-crystals to win!
    </div>
    <div id="gameOver" class="overlay">
      <h2>Energy Depleted!</h2>
      <p>No more connections available.</p>
      <button id="restartGame" class="btn btn-primary">Play Again</button>
    </div>
    <div id="gameWin" class="overlay">
      <h2>Cascade Complete!</h2>
      <p>All mega-crystals charged!</p>
      <button id="nextLevel" class="btn btn-primary">Next Level</button>
    </div>
  </div>

  <script>
    // --- SCREEN MANAGEMENT ---
    const screens = document.querySelectorAll('.screen');
    const gameOverOverlay = document.getElementById('gameOver');
    const gameWinOverlay = document.getElementById('gameWin');

    function showScreen(screenId) {
      screens.forEach(screen => screen.classList.remove('active'));
      const activeScreen = document.getElementById(screenId);
      if (activeScreen) activeScreen.classList.add('active');

      if (screenId === 'splash-screen' && window.splashScene) {
        window.splashScene.startAnimation();
      } else if (window.splashScene) {
        window.splashScene.stopAnimation();
      }
    }

    function showOverlay(overlayElement) {
      overlayElement.classList.add('visible');
    }

    function hideOverlay(overlayElement) {
      overlayElement.classList.remove('visible');
    }

    // --- SPLASH SCREEN 3D SCENE ---
    class SplashScene {
      constructor() {
        this.container = document.getElementById('splash-3d-container');
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x000000, 0);
        this.container.appendChild(this.renderer.domElement);

        this.camera.position.z = 10;
        this.crystals = [];
        this.isAnimating = false;

        this.setupLighting();
        this.createCrystals();
        this.createParticles();

        window.addEventListener('resize', this.onWindowResize.bind(this));
      }

      setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        this.scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
        pointLight1.position.set(5, 5, 5);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
        pointLight2.position.set(-5, -5, 3);
        this.scene.add(pointLight2);
      }

      createCrystals() {
        const crystalPositions = [
          { x: -4, y: 3, z: -2 },
          { x: 4, y: -2, z: -1 },
          { x: -3, y: -3, z: 1 },
          { x: 5, y: 2, z: 0 },
          { x: -2, y: 0, z: -3 },
          { x: 0, y: 4, z: 2 },
          { x: 3, y: -4, z: -1 },
          { x: -5, y: 1, z: 1 }
        ];

        const colors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff00, 0xff0066];

        crystalPositions.forEach((pos, i) => {
          const geometry = new THREE.OctahedronGeometry(0.5 + Math.random() * 0.3, 0);
          const material = new THREE.MeshPhongMaterial({
            color: colors[i % colors.length],
            shininess: 100,
            specular: 0xffffff,
            transparent: true,
            opacity: 0.8,
            emissive: colors[i % colors.length],
            emissiveIntensity: 0.3
          });

          const crystal = new THREE.Mesh(geometry, material);
          crystal.position.set(pos.x, pos.y, pos.z);
          crystal.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          crystal.userData = {
            originalPosition: { ...pos },
            floatSpeed: 0.5 + Math.random() * 1,
            rotationSpeed: {
              x: (Math.random() - 0.5) * 0.02,
              y: (Math.random() - 0.5) * 0.02,
              z: (Math.random() - 0.5) * 0.02
            },
            floatOffset: Math.random() * Math.PI * 2
          };

          this.crystals.push(crystal);
          this.scene.add(crystal);

          crystal.scale.set(0.01, 0.01, 0.01);
          new TWEEN.Tween(crystal.scale)
            .to({ x: 1, y: 1, z: 1 }, 1000)
            .easing(TWEEN.Easing.Elastic.Out)
            .delay(i * 100)
            .start();
        });
      }

      createParticles() {
        const particlesContainer = document.getElementById('particles-container');
        if (!particlesContainer) return;

        for (let i = 0; i < 30; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.top = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 15 + 's';
          particlesContainer.appendChild(particle);
        }
      }

      startAnimation() {
        this.isAnimating = true;
        this.animate();
      }

      stopAnimation() {
        this.isAnimating = false;
      }

      animate() {
        if (!this.isAnimating) return;

        requestAnimationFrame(this.animate.bind(this));
        TWEEN.update();

        const time = Date.now() * 0.001;

        this.crystals.forEach(crystal => {
          const userData = crystal.userData;
          crystal.position.y = userData.originalPosition.y +
            Math.sin(time * userData.floatSpeed + userData.floatOffset) * 0.5;
          crystal.rotation.x += userData.rotationSpeed.x;
          crystal.rotation.y += userData.rotationSpeed.y;
          crystal.rotation.z += userData.rotationSpeed.z;
        });

        this.renderer.render(this.scene, this.camera);
      }

      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    // --- CRYSTAL CLASS ---
    class Crystal {
      constructor(x, y, z, size, shapeData, row, col) {
        this.geometry = shapeData.geometryFactory(size);
        this.material = new THREE.MeshPhongMaterial({
          color: shapeData.color,
          shininess: 100,
          specular: 0xffffff,
          emissive: shapeData.color,
          emissiveIntensity: 0.2
        });
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.position.set(x, y, z);
        if (shapeData.name !== 'Sphere') {
          this.mesh.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );
        }
        this.color = shapeData.color;
        this.shapeType = shapeData.name;
        this.row = row;
        this.col = col;
        this.size = size;
        this.energyLevel = 0;
        this.maxEnergy = 100;
      }

      popIn(delay = 0) {
        this.mesh.scale.set(0.01, 0.01, 0.01);
        new TWEEN.Tween(this.mesh.scale)
          .to({ x: 1, y: 1, z: 1 }, 500)
          .easing(TWEEN.Easing.Back.Out)
          .delay(delay)
          .start();
      }

      explode(delay = 0, onComplete) {
        // Crystal explosion with energy burst
        const expandTween = new TWEEN.Tween(this.mesh.scale)
          .to({ x: 2, y: 2, z: 2 }, 150)
          .easing(TWEEN.Easing.Quadratic.Out)
          .delay(delay);

        const fadeTween = new TWEEN.Tween(this.material)
          .to({ opacity: 0 }, 200)
          .onComplete(() => {
            if (onComplete) onComplete();
          });

        expandTween.chain(fadeTween);
        expandTween.start();

        // Make material transparent for fade
        this.material.transparent = true;
      }

      pulse() {
        // Quick pulse animation when receiving energy
        const originalScale = this.mesh.scale.x;
        new TWEEN.Tween(this.mesh.scale)
          .to({ x: originalScale * 1.2, y: originalScale * 1.2, z: originalScale * 1.2 }, 100)
          .easing(TWEEN.Easing.Quadratic.Out)
          .yoyo(true)
          .repeat(1)
          .start();
      }

      addEnergy(amount) {
        this.energyLevel = Math.min(this.maxEnergy, this.energyLevel + amount);
        this.material.emissiveIntensity = 0.2 + (this.energyLevel / this.maxEnergy) * 0.5;
        this.pulse();
      }

      rotate() {
        this.mesh.rotation.x += 0.01;
        this.mesh.rotation.y += 0.02;
      }

      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }

    // --- MEGA CRYSTAL CLASS (Prize equivalent) ---
    class MegaCrystal {
      constructor(x, y, z, size) {
        this.geometry = new THREE.IcosahedronGeometry(size * 1.5, 1);
        this.material = new THREE.MeshPhongMaterial({
          color: 0xffd700,
          shininess: 100,
          specular: 0xffffff,
          emissive: 0xffaa00,
          emissiveIntensity: 0.5,
          transparent: true,
          opacity: 0.3,
          depthWrite: false
        });
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.position.set(x, y, z);
        this.mesh.renderOrder = 1;
        this.chargeLevel = 0;
        this.maxCharge = 100;
      }

      charge(amount) {
        this.chargeLevel = Math.min(this.maxCharge, this.chargeLevel + amount);
        const chargeRatio = this.chargeLevel / this.maxCharge;
        this.material.emissiveIntensity = 0.5 + chargeRatio * 0.5;
        this.material.opacity = 0.3 + chargeRatio * 0.4; // Get more visible as charged

        // Change color as it charges
        const hue = chargeRatio * 0.33; // 0 (red/gold) to 0.33 (green)
        this.material.color.setHSL(0.15 + hue * 0.2, 1, 0.5);

        // Pulse
        new TWEEN.Tween(this.mesh.scale)
          .to({ x: 1.2, y: 1.2, z: 1.2 }, 150)
          .easing(TWEEN.Easing.Quadratic.Out)
          .yoyo(true)
          .repeat(1)
          .start();
      }

      isFullyCharged() {
        return this.chargeLevel >= this.maxCharge;
      }

      collect() {
        new TWEEN.Tween(this.mesh.position)
          .to({ z: this.mesh.position.z + 10 }, 800)
          .easing(TWEEN.Easing.Back.In)
          .start();

        new TWEEN.Tween(this.mesh.scale)
          .to({ x: 0.01, y: 0.01, z: 0.01 }, 800)
          .easing(TWEEN.Easing.Back.In)
          .start();
      }

      rotate() {
        this.mesh.rotation.y += 0.03;
        this.mesh.rotation.x += 0.01;
      }

      dispose() {
        if (this.mesh.parent) this.mesh.parent.remove(this.mesh);
        this.geometry.dispose();
        this.material.dispose();
      }
    }

    // --- ENERGY PULSE EFFECT ---
    class EnergyPulse {
      constructor(fromPos, toPos, color, scene, onComplete) {
        this.scene = scene;

        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 1
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(fromPos);
        this.scene.add(this.mesh);

        // Animate to target
        new TWEEN.Tween(this.mesh.position)
          .to({ x: toPos.x, y: toPos.y, z: toPos.z }, 300)
          .easing(TWEEN.Easing.Quadratic.Out)
          .onComplete(() => {
            this.dispose();
            if (onComplete) onComplete();
          })
          .start();

        // Fade out
        new TWEEN.Tween(material)
          .to({ opacity: 0 }, 300)
          .start();
      }

      dispose() {
        if (this.mesh.parent) this.mesh.parent.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }
    }

    // --- MAIN GAME CLASS ---
    class CrystalConnections {
      constructor() {
        this.init();
      }

      init() {
        this.container = document.getElementById('container');
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0a1a);
        this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.container.appendChild(this.renderer.domElement);

        this.raycaster = new THREE.Raycaster();
        this.pointerPos = new THREE.Vector2();
        this.hoveredCrystal = null;
        this.crystals = [];
        this.megaCrystals = [];
        this.comboCount = 0;
        this.comboTimer = null;

        // Shape atlas matching the original game - shape determines color
        this.shapeAtlas = [
          { name: 'Sphere', color: 0x00ffff, geometryFactory: s => new THREE.SphereGeometry(s * 1.1, 20, 16) },
          { name: 'Cube', color: 0xff00ff, geometryFactory: s => new THREE.BoxGeometry(s * 1.5, s * 1.5, s * 1.5) },
          { name: 'Tetra', color: 0xffff00, geometryFactory: s => new THREE.TetrahedronGeometry(s * 1.4) },
          { name: 'Octa', color: 0x00ff00, geometryFactory: s => new THREE.OctahedronGeometry(s * 1.5) },
          { name: 'Icosa', color: 0xff0066, geometryFactory: s => new THREE.IcosahedronGeometry(s * 1.25) }
        ];

        this.isAnimating = false;
        this.gamePaused = false;

        this.scoreElement = document.getElementById('game-score');
        this.gameOverElement = document.getElementById('gameOver');
        this.gameWinElement = document.getElementById('gameWin');
        this.comboDisplay = document.getElementById('combo-display');

        this.scene.add(new THREE.AmbientLight(0xffffff, 0.3));

        const pointLight1 = new THREE.PointLight(0x00ffff, 1, 50);
        pointLight1.position.set(10, 10, 10);
        this.scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 1, 50);
        pointLight2.position.set(-10, -10, 10);
        this.scene.add(pointLight2);

        window.addEventListener('resize', this.onWindowResize.bind(this));
        this.container.addEventListener('mousedown', this.onPointerDown.bind(this));
        this.container.addEventListener('mousemove', this.onPointerMove.bind(this));
        this.container.addEventListener('touchstart', this.onPointerDown.bind(this), { passive: false });
        this.container.addEventListener('touchmove', this.onPointerMove.bind(this), { passive: false });
      }

      getPointerCoordinates(e) {
        const eventX = e.touches ? e.touches[0].clientX : e.clientX;
        const eventY = e.touches ? e.touches[0].clientY : e.clientY;
        this.pointerPos.x = (eventX / window.innerWidth) * 2 - 1;
        this.pointerPos.y = -(eventY / window.innerHeight) * 2 + 1;
      }

      onPointerMove(e) {
        if (this.isAnimating || this.gamePaused) return;
        this.getPointerCoordinates(e);
        this.raycaster.setFromCamera(this.pointerPos, this.camera);

        const crystalMeshes = this.crystals.flat().filter(c => c).map(c => c.mesh);
        const intersects = this.raycaster.intersectObjects(crystalMeshes);

        let newHoveredCrystal = null;
        if (intersects.length > 0) {
          const obj = intersects[0].object;
          for (let i = 0; i < this.crystals.length; i++) {
            for (let j = 0; j < this.crystals[i].length; j++) {
              if (this.crystals[i]?.[j]?.mesh === obj) {
                newHoveredCrystal = this.crystals[i][j];
                break;
              }
            }
          }
        }

        if (newHoveredCrystal !== this.hoveredCrystal) {
          this.clearHighlights();
          if (newHoveredCrystal) {
            this.hoveredCrystal = newHoveredCrystal;
            this.highlightConnectedGroup(newHoveredCrystal);
          } else {
            this.hoveredCrystal = null;
          }
        }
      }

      onPointerDown(e) {
        if (e.type === 'touchstart') e.preventDefault();
        if (this.isAnimating || this.gamePaused) return;

        this.getPointerCoordinates(e);
        this.raycaster.setFromCamera(this.pointerPos, this.camera);

        const crystalMeshes = this.crystals.flat().filter(c => c).map(c => c.mesh);
        const intersects = this.raycaster.intersectObjects(crystalMeshes);

        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;
          for (let i = 0; i < this.crystals.length; i++) {
            for (let j = 0; j < this.crystals[i].length; j++) {
              if (this.crystals[i]?.[j]?.mesh === clickedObject) {
                this.clearHighlights();
                this.processCrystalClick(i, j);
                return;
              }
            }
          }
        }
      }

      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.positionBoardElements();

        if (window.splashScene) {
          window.splashScene.onWindowResize();
        }
      }

      positionBoardElements() {
        if (this.crystals.length === 0) return;

        this.spacing = 1.0;
        this.crystalSize = this.spacing * 0.4;
        const boardWidth = this.gridSize * this.spacing;
        const boardHeight = this.gridSize * this.spacing;

        const fovInRadians = THREE.MathUtils.degToRad(this.camera.fov);
        const distH = (boardHeight / 2) / Math.tan(fovInRadians / 2);
        const distW = (boardWidth / 2) / (Math.tan(fovInRadians / 2) * this.camera.aspect);

        // Ensure camera is far enough for both dimensions with extra padding
        this.camera.position.z = Math.max(distH, distW) * 1.3;
        this.camera.lookAt(0, 0, 0);

        const offset = -((this.gridSize - 1) * this.spacing) / 2;

        for (let i = 0; i < this.gridSize; i++) {
          for (let j = 0; j < this.gridSize; j++) {
            if (this.crystals[i]?.[j]) {
              this.crystals[i][j].mesh.position.x = offset + j * this.spacing;
              this.crystals[i][j].mesh.position.y = offset + (this.gridSize - 1 - i) * this.spacing;
            }
          }
        }

        this.megaCrystals.forEach(mc => {
          if (mc.megaCrystalObj) {
            const crystal = this.crystals[mc.row]?.[mc.col];
            if (crystal) {
              mc.megaCrystalObj.mesh.position.x = crystal.mesh.position.x;
              mc.megaCrystalObj.mesh.position.y = crystal.mesh.position.y;
              mc.megaCrystalObj.mesh.position.z = crystal.mesh.position.z + 0.1;
            }
          }
        });
      }

      clearBoard() {
        this.clearHighlights();
        const toRemove = [];
        this.scene.traverse(o => {
          if (o.type === 'Mesh' && o !== this.scene.background) {
            toRemove.push(o);
          }
        });
        toRemove.forEach(o => {
          if (o.parent) o.parent.remove(o);
          if (o.geometry) o.geometry.dispose();
          if (o.material) {
            if (Array.isArray(o.material)) {
              o.material.forEach(m => m.dispose());
            } else {
              o.material.dispose();
            }
          }
        });
        this.crystals = [];
        this.megaCrystals = [];
        TWEEN.removeAll();
      }

      createNewBoard() {
        this.clearBoard();
        this.score = 0;
        this.comboCount = 0;
        this.updateScore();
        this.updateComboDisplay();
        this.pauseGame(false);
        this.isAnimating = true;

        this.gridSize = parseInt(document.getElementById('rows-setting').value);
        this.difficulty = document.getElementById('difficulty-setting').value;

        // Set minimum group size based on difficulty
        this.minGroupSize = this.difficulty === 'easy' ? 2 : this.difficulty === 'hard' ? 3 : 2;

        this.generateBoardState();
        this.positionBoardElements();
        this.animateCrystalsIn();
      }

      generateBoardState() {
        this.crystals = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
        const offset = -((this.gridSize - 1) * 1.0) / 2;

        // Place mega-crystals
        this.megaCrystals = [];
        const megaCrystalCount = Math.max(3, Math.floor(this.gridSize / 3));
        const positions = [];
        for (let i = 0; i < this.gridSize; i++) {
          for (let j = 0; j < this.gridSize; j++) {
            positions.push({ row: i, col: j });
          }
        }
        positions.sort(() => 0.5 - Math.random());

        for (let p = 0; p < megaCrystalCount; p++) {
          const pos = positions[p];
          this.megaCrystals.push({ ...pos, charged: false });
        }

        // Generate crystals with shape-based colors
        for (let i = 0; i < this.gridSize; i++) {
          for (let j = 0; j < this.gridSize; j++) {
            const shapeData = this.shapeAtlas[Math.floor(Math.random() * this.shapeAtlas.length)];
            const x = offset + j * 1.0;
            const y = offset + (this.gridSize - 1 - i) * 1.0;

            const crystal = new Crystal(x, y, 0, 0.4, shapeData, i, j);
            this.crystals[i][j] = crystal;
            this.scene.add(crystal.mesh);

            const megaCrystalData = this.megaCrystals.find(mc => mc.row === i && mc.col === j);
            if (megaCrystalData) {
              const megaCrystal = new MegaCrystal(x, y, 0.1, 0.4);
              this.scene.add(megaCrystal.mesh);
              megaCrystalData.megaCrystalObj = megaCrystal;
              megaCrystalData.attachedCrystal = crystal; // Keep reference for positioning
            }
          }
        }
      }

      animateCrystalsIn() {
        let maxDelay = 0;
        for (let i = 0; i < this.gridSize; i++) {
          for (let j = 0; j < this.gridSize; j++) {
            if (this.crystals[i]?.[j]) {
              const delay = (i + j) * 30;
              this.crystals[i][j].popIn(delay);
              if (delay > maxDelay) maxDelay = delay;
            }
          }
        }
        setTimeout(() => {
          this.isAnimating = false;
        }, maxDelay + 500);
      }

      processCrystalClick(row, col) {
        const crystal = this.crystals[row]?.[col];
        if (!crystal) return;

        const connected = this.findConnectedCrystals(row, col, crystal.shapeType);
        if (connected.length < this.minGroupSize) return;

        this.isAnimating = true;

        // Combo system
        if (this.comboTimer) clearTimeout(this.comboTimer);
        this.comboCount++;
        this.updateComboDisplay();
        this.comboTimer = setTimeout(() => {
          this.comboCount = 0;
          this.updateComboDisplay();
        }, 2000);

        const baseScore = connected.length * 10;
        const comboMultiplier = 1 + (this.comboCount - 1) * 0.5;
        this.score += Math.floor(baseScore * comboMultiplier);

        this.explodeCrystals(connected);
      }

      explodeCrystals(connected) {
        let callbacksPending = connected.length;

        const onExplosionComplete = () => {
          if (--callbacksPending === 0) {
            connected.forEach(({ row: r, col: c }) => {
              if (this.crystals[r]) this.crystals[r][c] = null;
            });
            this.updateScore();

            // Send energy pulses to neighbors and mega-crystals
            this.sendEnergyPulses(connected);

            setTimeout(() => this.applyGravity(), 300);
          }
        };

        connected.forEach(({ row: r, col: c }, index) => {
          const crystal = this.crystals[r]?.[c];
          if (crystal) {
            crystal.explode(index * 30, () => {
              this.scene.remove(crystal.mesh);
              crystal.dispose();
              onExplosionComplete();
            });
          } else {
            onExplosionComplete();
          }
        });
      }

      sendEnergyPulses(explodedPositions) {
        // Send energy primarily to mega-crystals, then to adjacent crystals
        explodedPositions.forEach(({ row, col }) => {
          const sourcePos = new THREE.Vector3(
            -((this.gridSize - 1) * this.spacing) / 2 + col * this.spacing,
            -((this.gridSize - 1) * this.spacing) / 2 + (this.gridSize - 1 - row) * this.spacing,
            0
          );

          // Prioritize mega-crystals - send energy to nearby mega-crystals first
          this.megaCrystals.forEach(mc => {
            if (!mc.charged && mc.megaCrystalObj) {
              const dist = Math.abs(mc.row - row) + Math.abs(mc.col - col);
              if (dist <= 2) {
                setTimeout(() => {
                  new EnergyPulse(
                    sourcePos.clone(),
                    mc.megaCrystalObj.mesh.position.clone(),
                    0xffd700,
                    this.scene,
                    () => {
                      mc.megaCrystalObj.charge(20);
                      if (mc.megaCrystalObj.isFullyCharged() && !mc.charged) {
                        mc.charged = true;
                        this.score += 100;
                        this.updateScore();
                      }
                    }
                  );
                }, Math.random() * 100);
              }
            }
          });

          // Then send to adjacent crystals
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = row + dr;
              const nc = col + dc;
              if (nr >= 0 && nr < this.gridSize && nc >= 0 && nc < this.gridSize) {
                const adjCrystal = this.crystals[nr]?.[nc];
                if (adjCrystal) {
                  setTimeout(() => {
                    new EnergyPulse(
                      sourcePos.clone(),
                      adjCrystal.mesh.position.clone(),
                      adjCrystal.color,
                      this.scene,
                      () => adjCrystal.addEnergy(10)
                    );
                  }, Math.random() * 150);
                }
              }
            }
          }
        });
      }

      findConnectedCrystals(row, col, targetType) {
        const visited = new Set();
        const connected = [];
        const stack = [{ row, col }];
        visited.add(`${row},${col}`);

        while (stack.length > 0) {
          const { row: r, col: c } = stack.pop();
          const crystal = this.crystals[r]?.[c];

          if (!crystal || crystal.shapeType !== targetType) continue;

          connected.push({ row: r, col: c });

          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const nr = r + dr;
              const nc = c + dc;
              if (nr >= 0 && nr < this.gridSize && nc >= 0 && nc < this.gridSize &&
                  !visited.has(`${nr},${nc}`)) {
                visited.add(`${nr},${nc}`);
                stack.push({ row: nr, col: nc });
              }
            }
          }
        }
        return connected;
      }

      applyGravity() {
        let animationsPending = 0;
        const offsetY = -((this.gridSize - 1) * this.spacing) / 2;

        const onGravityComplete = () => {
          if (--animationsPending === 0) {
            this.removeEmptyColumns();
          }
        };

        for (let j = 0; j < this.gridSize; j++) {
          let emptySpaces = 0;
          for (let i = this.gridSize - 1; i >= 0; i--) {
            if (!this.crystals[i][j]) {
              emptySpaces++;
            } else if (emptySpaces > 0) {
              const crystal = this.crystals[i][j];
              const targetRow = i + emptySpaces;
              this.crystals[targetRow][j] = crystal;
              this.crystals[i][j] = null;
              crystal.row = targetRow;

              const newY = offsetY + (this.gridSize - 1 - targetRow) * this.spacing;
              animationsPending++;

              new TWEEN.Tween(crystal.mesh.position)
                .to({ y: newY }, 400)
                .easing(TWEEN.Easing.Bounce.Out)
                .onComplete(onGravityComplete)
                .start();

              // Update mega-crystal row tracking (position updates in animate loop)
              this.megaCrystals.filter(mc => mc.row === i && mc.col === j && !mc.charged).forEach(mc => {
                mc.row = targetRow;
              });
            }
          }
        }

        if (animationsPending === 0) {
          this.removeEmptyColumns();
        }
      }

      removeEmptyColumns() {
        const emptyCols = [];
        for (let j = 0; j < this.gridSize; j++) {
          let hasAnyCrystal = false;
          for (let i = 0; i < this.gridSize; i++) {
            if (this.crystals[i][j]) {
              hasAnyCrystal = true;
              break;
            }
          }
          if (!hasAnyCrystal) {
            emptyCols.push(j);
          }
        }

        if (emptyCols.length > 0) {
          // Auto-charge any mega-crystals in cleared columns
          emptyCols.forEach(col => {
            const megaCrystalInCol = this.megaCrystals.find(mc => mc.col === col && !mc.charged);
            if (megaCrystalInCol && megaCrystalInCol.megaCrystalObj) {
              // Fully charge it
              const remainingCharge = megaCrystalInCol.megaCrystalObj.maxCharge - megaCrystalInCol.megaCrystalObj.chargeLevel;
              megaCrystalInCol.megaCrystalObj.charge(remainingCharge);
              megaCrystalInCol.charged = true;
              this.score += 100;
            }
          });

          this.score += emptyCols.length * 100;
          this.updateScore();

          let animationsPending = 0;
          const newGridSize = this.gridSize - emptyCols.length;
          const offsetX = -((newGridSize - 1) * this.spacing) / 2;

          const onShiftComplete = () => {
            if (--animationsPending === 0) {
              this.finalizeColumnRemoval(emptyCols);
            }
          };

          for (let j = 0; j < this.gridSize; j++) {
            const shift = emptyCols.filter(c => c < j).length;
            if (shift > 0) {
              const newCol = j - shift;
              const newX = offsetX + newCol * this.spacing;

              for (let i = 0; i < this.gridSize; i++) {
                const crystal = this.crystals[i][j];
                if (crystal) {
                  animationsPending++;
                  new TWEEN.Tween(crystal.mesh.position)
                    .to({ x: newX }, 500)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onComplete(onShiftComplete)
                    .start();

                  // Mega-crystals will follow via animate loop
                }
              }
            }
          }

          if (animationsPending === 0) {
            this.finalizeColumnRemoval(emptyCols);
          }
        } else {
          this.checkGameState();
        }
      }

      finalizeColumnRemoval(emptyCols) {
        // Remove empty columns from data structure
        emptyCols.sort((a, b) => b - a).forEach(col => {
          for (let i = 0; i < this.gridSize; i++) {
            this.crystals[i].splice(col, 1);
          }
        });
        this.gridSize -= emptyCols.length;

        // Update internal col property for all crystals and mega-crystals
        for (let i = 0; i < this.gridSize; i++) {
          for (let j = 0; j < this.gridSize; j++) {
            if (this.crystals[i]?.[j]) {
              this.crystals[i][j].col = j;
            }
          }
        }

        this.megaCrystals.forEach(mc => {
          const shift = emptyCols.filter(c => c < mc.col).length;
          if (shift > 0) mc.col -= shift;
        });

        // Recenter camera based on new board size
        this.positionBoardElements();
        this.checkGameState();
      }

      checkGameState() {
        this.isAnimating = false;

        // Check win condition
        if (this.megaCrystals.length > 0 && this.megaCrystals.every(mc => mc.charged)) {
          this.winLevel();
          return;
        }

        // Check lose condition
        if (!this.hasValidMoves()) {
          this.endGame();
        }
      }

      hasValidMoves() {
        for (let i = 0; i < this.gridSize; i++) {
          for (let j = 0; j < this.gridSize; j++) {
            const crystal = this.crystals[i]?.[j];
            if (crystal && this.findConnectedCrystals(i, j, crystal.shapeType).length >= this.minGroupSize) {
              return true;
            }
          }
        }
        return false;
      }

      endGame() {
        this.pauseGame(true);
        showOverlay(this.gameOverElement);
      }

      winLevel() {
        this.pauseGame(true);
        showOverlay(this.gameWinElement);

        // Animate mega-crystals flying away
        this.megaCrystals.forEach((mc, index) => {
          if (mc.megaCrystalObj) {
            setTimeout(() => {
              mc.megaCrystalObj.collect();
            }, index * 200);
          }
        });
      }

      pauseGame(isPaused) {
        this.gamePaused = isPaused;
        this.isAnimating = isPaused;
      }

      updateScore() {
        this.scoreElement.textContent = this.score;
      }

      updateComboDisplay() {
        if (this.comboCount > 1) {
          this.comboDisplay.textContent = `${this.comboCount}x COMBO!`;
          this.comboDisplay.classList.add('visible');
        } else {
          this.comboDisplay.classList.remove('visible');
        }
      }

      clearHighlights() {
        this.crystals.flat().filter(c => c).forEach(c => {
          c.mesh.material.emissiveIntensity = 0.2;
        });
      }

      highlightConnectedGroup(crystal) {
        const connected = this.findConnectedCrystals(crystal.row, crystal.col, crystal.shapeType);
        if (connected.length < this.minGroupSize) return;

        connected.forEach(({ row, col }) => {
          const c = this.crystals[row][col];
          if (c) {
            c.mesh.material.emissiveIntensity = 0.8;
          }
        });
      }

      animate() {
        requestAnimationFrame(this.animate.bind(this));
        TWEEN.update();

        if (!this.gamePaused) {
          this.crystals.flat().filter(c => c).forEach(c => c.rotate());

          // Keep mega-crystals positioned above their crystals and rotate them
          this.megaCrystals.forEach(mc => {
            if (!mc.charged && mc.megaCrystalObj) {
              // Ensure mega-crystal stays positioned above its crystal
              const crystal = this.crystals[mc.row]?.[mc.col];
              if (crystal) {
                mc.megaCrystalObj.mesh.position.x = crystal.mesh.position.x;
                mc.megaCrystalObj.mesh.position.y = crystal.mesh.position.y;
                mc.megaCrystalObj.mesh.position.z = crystal.mesh.position.z + 0.1;
              }
              mc.megaCrystalObj.rotate();
            }
          });
        }

        this.renderer.render(this.scene, this.camera);
      }
    }

    // --- GLOBAL UI EVENT LISTENERS ---
    document.addEventListener('DOMContentLoaded', () => {
      window.splashScene = new SplashScene();
      window.splashScene.startAnimation();

      const game = new CrystalConnections();
      game.animate();

      document.getElementById('start-game-btn').addEventListener('click', () => {
        showScreen('game-screen');
        game.createNewBoard();
      });

      document.getElementById('settings-btn').addEventListener('click', () => {
        showScreen('settings-screen');
      });

      document.getElementById('back-to-splash-btn').addEventListener('click', () => {
        showScreen('splash-screen');
      });

      document.getElementById('game-menu-btn').addEventListener('click', () => {
        game.pauseGame(true);
        showScreen('splash-screen');
      });

      document.getElementById('restartGame').addEventListener('click', () => {
        hideOverlay(gameOverOverlay);
        game.createNewBoard();
      });

      document.getElementById('nextLevel').addEventListener('click', () => {
        hideOverlay(gameWinOverlay);
        game.createNewBoard();
      });
    });
  </script>
</body>
</html>
