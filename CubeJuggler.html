<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cube juggler - Universal</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            font-family: Arial, sans-serif;
        }
        
        /* Mode Selection Screen */
        #mode-selection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }
        
        #mode-selection h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        #mode-selection p {
            font-size: 20px;
            margin-bottom: 40px;
            opacity: 0.9;
        }
        
        .mode-buttons {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .mode-btn {
            background: rgba(255,255,255,0.2);
            border: 3px solid rgba(255,255,255,0.4);
            color: white;
            padding: 30px 40px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        
        .mode-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.8);
            transform: translateY(-5px);
        }
        
        .mode-btn:active {
            transform: translateY(-2px);
        }
        
        .mode-icon {
            font-size: 48px;
            display: block;
            margin-bottom: 15px;
        }
        
        .mode-description {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 10px;
            line-height: 1.3;
        }

        /* Game UI */
        #game-container {
            display: none;
        }
        
        #ui-container {
            position: fixed;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 100;
        }
        
        .ui-text {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            margin: 5px;
            font-size: 18px;
            font-weight: bold;
        }
        
        #score-container {
            float: right;
            text-align: right;
        }
        
        .lives {
            color: #ff4444;
            font-size: 28px;
            letter-spacing: 3px;
            transition: transform 0.2s, color 0.2s;
            display: inline-block;
        }
        
        .life-lost {
            animation: lifeLoss 0.6s ease-out;
        }
        
        @keyframes lifeLoss {
            0% { transform: scale(1); color: #ff4444; }
            50% { transform: scale(1.5); color: #ff0000; }
            100% { transform: scale(1); color: #ff4444; }
        }
        
        #control-buttons {
            float: left;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            pointer-events: auto;
            cursor: pointer;
            background: #ff4444;
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            transition: transform 0.2s;
            font-size: 14px;
            font-weight: bold;
            touch-action: manipulation;
        }
        
        .control-btn:hover, .control-btn:active {
            transform: scale(0.95);
        }
        
        #game-over {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            font-size: 36px;
            text-align: center;
            padding-top: 40vh;
            box-sizing: border-box;
            pointer-events: auto;
            z-index: 200;
            touch-action: manipulation;
        }
        
        /* Mobile-specific elements */
        #paddle-zone {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25vh;
            background: linear-gradient(to top, rgba(0,255,0,0.2), rgba(0,255,0,0.05));
            border-top: 2px solid rgba(0,255,0,0.4);
            pointer-events: auto;
            z-index: 50;
            touch-action: none;
        }
        
        #paddle-zone-label {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.8);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .touch-indicator {
            position: fixed;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            pointer-events: none;
            z-index: 150;
            transform: translate(-50%, -50%);
            animation: touchPulse 0.3s ease-out;
        }
        
        @keyframes touchPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
        }
        
        .sphere-touch {
            border-color: #ffd700;
            background: rgba(255,215,0,0.3);
        }
        
        .paddle-touch {
            border-color: #00ff00;
            background: rgba(0,255,0,0.3);
        }
        
        /* Instructions */
        #how-to-play {
            position: fixed;
            bottom: 15px;
            left: 15px;
            right: 15px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 16px;
            line-height: 1.4;
            pointer-events: auto;
            text-align: center;
        }
        
        .key-point {
            color: #ffd700;
            font-weight: bold;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            #mode-selection h1 { font-size: 36px; }
            #mode-selection p { font-size: 18px; }
            .mode-btn { 
                padding: 25px 30px; 
                font-size: 20px;
                min-width: 180px;
            }
            .mode-buttons { gap: 20px; }
            .mode-icon { font-size: 40px; }
        }
    </style>
</head>
<body>
    <!-- Mode Selection Screen -->
    <div id="mode-selection">
        <h1>üéÆ Cube juggler</h1>
        <p>Choose your control method to start playing!</p>
        
        <div class="mode-buttons">
            <button class="mode-btn" data-mode="desktop">
                <span class="mode-icon">üñ±Ô∏è</span>
                Desktop Mode
                <div class="mode-description">
                    Mouse to move paddle<br>
                    Click to pop spheres
                </div>
            </button>
            
            <button class="mode-btn" data-mode="mobile">
                <span class="mode-icon">üëÜ</span>
                Mobile Mode
                <div class="mode-description">
                    Swipe to move paddle<br>
                    Tap to pop spheres
                </div>
            </button>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <div id="ui-container">
            <div id="control-buttons">
                <button id="back-btn" class="control-btn">‚Üê Back</button>
            </div>
            <div id="score-container">
                <div id="score" class="ui-text">Score: 0</div>
                <div id="level" class="ui-text">Level: 1</div>
                <div id="lives" class="ui-text">Lives: <span class="lives">‚ô•‚ô•‚ô•‚ô•</span></div>
            </div>
        </div>
        
        <div id="paddle-zone">
            <div id="paddle-zone-label">Swipe here to move paddle</div>
        </div>
        
        <div id="game-over">Game Over<br><br>Tap to play again</div>
        
        <div id="how-to-play">
            <span id="instructions-text"></span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        class Paddle {
            constructor(scene) {
                const geometry = new THREE.BoxGeometry(4, 0.5, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.y = -8;
                scene.add(this.mesh);
            }

            update(inputX) {
                // Tighter bounds for mobile compatibility - keep paddle well within screen
                const x = Math.max(-6, Math.min(6, inputX * 7));
                this.mesh.position.x = x;
            }

            getBounds() {
                return {
                    left: this.mesh.position.x - 2,
                    right: this.mesh.position.x + 2,
                    top: this.mesh.position.y + 0.25,
                    bottom: this.mesh.position.y - 0.25
                };
            }
        }

        class Cube {
            constructor(scene, position, color) {
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshBasicMaterial({ color });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * -0.1 - 0.1,
                    0
                );
                
                this.rotation = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                this.paddleBounces = 0;
                this.baseScale = 0.5;
                this.baseValue = 10;
                this.scene = scene;
                
                scene.add(this.mesh);
            }

            explode() {
                const particles = [];
                const numParticles = 8;
                const color = this.mesh.material.color;
                
                for (let i = 0; i < numParticles; i++) {
                    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const material = new THREE.MeshBasicMaterial({ color: color });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    particle.position.copy(this.mesh.position);
                    
                    const angle = (i / numParticles) * Math.PI * 2;
                    const speed = 0.3;
                    const velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        0
                    );
                    
                    this.scene.add(particle);
                    particles.push({ mesh: particle, velocity });
                }

                const startScale = this.mesh.scale.x;
                new TWEEN.Tween({ scale: startScale })
                    .to({ scale: 0 }, 500)
                    .onUpdate((obj) => {
                        particles.forEach((particle) => {
                            particle.mesh.position.add(particle.velocity);
                            particle.velocity.y -= 0.01;
                            particle.mesh.scale.setScalar(obj.scale * 0.5);
                            particle.mesh.rotation.x += 0.1;
                            particle.mesh.rotation.y += 0.1;
                        });
                    })
                    .onComplete(() => {
                        particles.forEach(particle => this.scene.remove(particle.mesh));
                    })
                    .start();
            }

            update() {
                this.velocity.y -= 0.01;
                
                const MAX_SPEED = 0.5;
                const currentSpeed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);
                if (currentSpeed > MAX_SPEED) {
                    const scale = MAX_SPEED / currentSpeed;
                    this.velocity.x *= scale;
                    this.velocity.y *= scale;
                }
                
                this.mesh.position.add(this.velocity);
                
                this.mesh.rotation.x += this.rotation.x + Math.abs(this.velocity.x) * 0.1;
                this.mesh.rotation.y += this.rotation.y + Math.abs(this.velocity.y) * 0.1;
                this.mesh.rotation.z += this.rotation.z;
                
                // Tighter wall boundaries for mobile screens
                const currentScale = this.baseScale * (1 + (this.paddleBounces * 0.5));
                const scaledSize = 0.5 * currentScale;
                const WALL_X = 7; // Reduced from 9.5 to keep cubes on screen

                if (Math.abs(this.mesh.position.x) > WALL_X - scaledSize) {
                    this.velocity.x *= -0.8;
                    this.mesh.position.x = Math.sign(this.mesh.position.x) * (WALL_X - scaledSize);
                    this.velocity.y += 0.05;
                    this.velocity.y *= 0.9 + (Math.random() * 0.2);
                    this.rotation.z += (Math.random() - 0.5) * 0.2;
                    
                    new TWEEN.Tween(this.mesh.scale)
                        .to({
                            x: currentScale * 0.5,
                            y: currentScale * 1.5,
                            z: currentScale * 1.5
                        }, 100)
                        .easing(TWEEN.Easing.Elastic.Out)
                        .chain(
                            new TWEEN.Tween(this.mesh.scale)
                                .to({
                                    x: currentScale,
                                    y: currentScale,
                                    z: currentScale
                                }, 200)
                                .easing(TWEEN.Easing.Elastic.Out)
                        )
                        .start();
                }
                
                // Visual warning when cube is about to auto-pop (at 7 bounces)
                if (this.paddleBounces === 7 && !this.hasWarned) {
                    this.hasWarned = true;
                    const originalColor = this.mesh.material.color.clone();
                    new TWEEN.Tween(this.mesh.material.color)
                        .to(new THREE.Color(0xffffff), 150) // Flash white
                        .yoyo(true)
                        .repeat(3)
                        .onComplete(() => {
                            this.mesh.material.color.copy(originalColor);
                        })
                        .start();
                }
                
                const newScale = this.baseScale * (1 + (this.paddleBounces * 0.5));
                this.mesh.scale.set(newScale, newScale, newScale);
                
                if (this.mesh.position.y <= -10) {
                    this.explode();
                    return false;
                }
                return true;
            }

            checkPaddleCollision(paddle) {
                const bounds = paddle.getBounds();
                const pos = this.mesh.position;
                
                if (pos.y <= bounds.top && pos.y >= bounds.bottom &&
                    pos.x >= bounds.left && pos.x <= bounds.right) {
                    this.paddleBounces++;
                    const pointMultiplier = Math.pow(2, this.paddleBounces - 1);
                    const points = this.baseValue * pointMultiplier;
                    
                    const MAX_BOUNCE_BOOST = 0.4;
                    const bounceBoost = Math.min(0.2 * this.paddleBounces, MAX_BOUNCE_BOOST);
                    this.velocity.y = Math.abs(this.velocity.y) * 0.8 + bounceBoost;
                    this.velocity.x += (pos.x - paddle.mesh.position.x) * 0.1;
                    this.velocity.x += (Math.random() - 0.5) * 0.1;
                    
                    const newScale = this.baseScale * (1 + (this.paddleBounces * 0.5));
                    
                    new TWEEN.Tween(this.mesh.scale)
                        .to({
                            x: newScale * 1.5,
                            y: newScale * 0.5,
                            z: newScale * 1.5
                        }, 100)
                        .easing(TWEEN.Easing.Elastic.Out)
                        .chain(
                            new TWEEN.Tween(this.mesh.scale)
                                .to({
                                    x: newScale,
                                    y: newScale,
                                    z: newScale
                                }, 200)
                                .easing(TWEEN.Easing.Elastic.Out)
                        )
                        .start();
                    
                    return points;
                }
                return 0;
            }

            // Check if cube has reached maximum size and should auto-pop
            shouldAutoPop() {
                return this.paddleBounces >= 8; // Auto-pop after 8 bounces for maximum juiciness
            }

            // Get position for spawning new cubes when auto-popping
            getPosition() {
                return this.mesh.position.clone();
            }

            // Get color for spawning new cubes
            getColor() {
                return this.mesh.material.color.getHex();
            }
        }

        class TouchManager {
            constructor() {
                this.activeTouches = new Map();
                this.paddleTouch = null;
            }

            addTouch(touch, type) {
                this.activeTouches.set(touch.identifier, { touch, type, startTime: Date.now() });
                
                if (type === 'paddle') {
                    this.paddleTouch = touch.identifier;
                }
            }

            removeTouch(touchId) {
                this.activeTouches.delete(touchId);
                
                if (this.paddleTouch === touchId) {
                    this.paddleTouch = null;
                }
            }

            updateTouch(touch) {
                if (this.activeTouches.has(touch.identifier)) {
                    const touchData = this.activeTouches.get(touch.identifier);
                    touchData.touch = touch;
                }
            }

            getPaddleTouch() {
                if (this.paddleTouch && this.activeTouches.has(this.paddleTouch)) {
                    return this.activeTouches.get(this.paddleTouch).touch;
                }
                return null;
            }

            clear() {
                this.activeTouches.clear();
                this.paddleTouch = null;
            }
        }

        class Game {
            constructor(mode) {
                this.mode = mode; // 'desktop' or 'mobile'
                
                // Fresh game state initialization
                this.score = 0;
                this.level = 1;
                this.lives = 4;
                this.isGameOver = false;
                this.spheres = [];
                this.cubes = [];
                this.borderTubes = []; // Track border tubes for preservation during cleanup
                this.touchManager = new TouchManager();
                this.spawnInterval = null;
                
                // Vibrant color palette (no red to avoid confusion with warning flash)
                this.colors = [
                    0x00ff00, // Bright Green
                    0x0080ff, // Bright Blue  
                    0xffff00, // Bright Yellow
                    0xff00ff, // Bright Magenta
                    0x00ffff, // Cyan
                    0xff8000, // Orange
                    0x8000ff  // Purple
                ];
                
                this.setupUI();
                this.setupScene();
                this.setupEvents();
                this.paddle = new Paddle(this.scene);
                this.animate();
                this.spawnInterval = setInterval(() => this.spawnSphere(), 3000);
            }

            setupUI() {
                // Show game container
                document.getElementById('game-container').style.display = 'block';
                
                // Setup instructions based on mode
                const instructionsElement = document.getElementById('instructions-text');
                if (this.mode === 'mobile') {
                    document.getElementById('paddle-zone').style.display = 'block';
                    instructionsElement.innerHTML = '<span class="key-point">Two-finger play:</span> Swipe in green zone to move paddle, tap <span class="key-point">spheres</span> with other finger!';
                } else {
                    document.getElementById('paddle-zone').style.display = 'none';
                    instructionsElement.innerHTML = 'Move mouse to control paddle, <span class="key-point">click spheres</span> to break them, bounce cubes for points. <span class="key-point">4 lives</span> - don\'t miss!';
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 15;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Safely append renderer to body
                try {
                    document.body.appendChild(this.renderer.domElement);
                } catch (error) {
                    console.log('Renderer setup handled:', error.message);
                }

                // Add border tubes to show playfield boundaries
                this.borderTubes = [];
                this.createBorderTubes();

                this.raycaster = new THREE.Raycaster();
                this.inputPoint = new THREE.Vector2();
            }

            createBorderTubes() {
                // Create white tube borders at the wall boundaries
                const tubeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 20, 8);
                const tubeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    opacity: 0.8,
                    transparent: true
                });
                
                // Left border tube
                const leftTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                leftTube.position.set(-7, 0, 0);
                this.scene.add(leftTube);
                this.borderTubes.push(leftTube);
                
                // Right border tube  
                const rightTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                rightTube.position.set(7, 0, 0);
                this.scene.add(rightTube);
                this.borderTubes.push(rightTube);
            }

            setupEvents() {
                // Only prevent default touch behaviors on game elements in mobile mode
                if (this.mode === 'mobile') {
                    // Let UI elements handle their own touch events normally
                    document.body.style.touchAction = 'manipulation';
                }

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                if (this.mode === 'desktop') {
                    this.setupDesktopEvents();
                } else {
                    this.setupMobileEvents();
                }

                // Common events - use both click and touch for compatibility
                const backBtn = document.getElementById('back-btn');
                backBtn.addEventListener('click', () => this.backToMenu());
                backBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.backToMenu();
                });

                const gameOverEl = document.getElementById('game-over');
                gameOverEl.addEventListener('click', () => this.restartGame());
                gameOverEl.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.restartGame();
                });
            }

            setupDesktopEvents() {
                // Mouse movement for paddle
                window.addEventListener('mousemove', (event) => {
                    if (this.isGameOver) return;
                    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                    this.paddle.update(mouseX);
                });

                // Mouse click for spheres
                this.renderer.domElement.addEventListener('click', (event) => {
                    if (this.isGameOver) return;
                    
                    this.inputPoint.x = (event.clientX / window.innerWidth) * 2 - 1;
                    this.inputPoint.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    this.checkSphereInput();
                });

                // Also support touch events for desktop mode (hybrid devices)
                this.renderer.domElement.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (this.isGameOver) return;
                    
                    const touch = event.changedTouches[0];
                    this.inputPoint.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    this.inputPoint.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    
                    this.checkSphereInput();
                }, { passive: false });
            }

            setupMobileEvents() {
                // Touch events for paddle control
                const paddleZone = document.getElementById('paddle-zone');
                
                paddleZone.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (this.isGameOver) return;
                    
                    for (let touch of event.changedTouches) {
                        this.touchManager.addTouch(touch, 'paddle');
                        this.showTouchIndicator(touch.clientX, touch.clientY, 'paddle-touch');
                        this.updatePaddleFromTouch(touch);
                    }
                }, { passive: false });

                paddleZone.addEventListener('touchmove', (event) => {
                    event.preventDefault();
                    if (this.isGameOver) return;
                    
                    for (let touch of event.changedTouches) {
                        this.touchManager.updateTouch(touch);
                        if (touch.identifier === this.touchManager.paddleTouch) {
                            this.updatePaddleFromTouch(touch);
                        }
                    }
                }, { passive: false });

                paddleZone.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    for (let touch of event.changedTouches) {
                        this.touchManager.removeTouch(touch.identifier);
                    }
                }, { passive: false });

                // Touch events for sphere popping - attach to canvas directly
                this.renderer.domElement.addEventListener('touchstart', (event) => {
                    event.preventDefault();
                    if (this.isGameOver) return;
                    
                    for (let touch of event.changedTouches) {
                        // Skip if touch is in paddle zone area
                        const paddleZoneHeight = window.innerHeight * 0.25;
                        if (touch.clientY > window.innerHeight - paddleZoneHeight) {
                            continue;
                        }
                        
                        this.touchManager.addTouch(touch, 'sphere');
                        this.showTouchIndicator(touch.clientX, touch.clientY, 'sphere-touch');
                        this.checkSphereTouch(touch);
                    }
                }, { passive: false });

                this.renderer.domElement.addEventListener('touchend', (event) => {
                    event.preventDefault();
                    for (let touch of event.changedTouches) {
                        this.touchManager.removeTouch(touch.identifier);
                    }
                }, { passive: false });
            }

            showTouchIndicator(x, y, className) {
                const indicator = document.createElement('div');
                indicator.className = `touch-indicator ${className}`;
                indicator.style.left = x + 'px';
                indicator.style.top = y + 'px';
                document.body.appendChild(indicator);
                
                setTimeout(() => {
                    try {
                        if (indicator && indicator.parentNode) {
                            indicator.parentNode.removeChild(indicator);
                        }
                    } catch (error) {
                        console.log('Touch indicator cleanup handled:', error.message);
                    }
                }, 300);
            }

            updatePaddleFromTouch(touch) {
                const touchX = (touch.clientX / window.innerWidth) * 2 - 1;
                this.paddle.update(touchX);
            }

            checkSphereTouch(touch) {
                this.inputPoint.x = (touch.clientX / window.innerWidth) * 2 - 1;
                this.inputPoint.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                this.checkSphereInput();
            }

            checkSphereInput() {
                this.raycaster.setFromCamera(this.inputPoint, this.camera);
                const intersects = this.raycaster.intersectObjects(this.spheres);
                
                if (intersects.length > 0) {
                    this.popSphere(intersects[0].object);
                }
            }

            spawnSphere() {
                if (this.isGameOver) return;

                const geometry = new THREE.SphereGeometry(1, 32, 32);
                const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                const material = new THREE.MeshBasicMaterial({ color });
                const sphere = new THREE.Mesh(geometry, material);
                
                // Tighter spawn range to keep spheres on screen
                sphere.position.x = Math.random() * 12 - 6;
                sphere.position.y = Math.random() * 10;
                sphere.position.z = 0;
                sphere.userData.color = color;
                sphere.userData.originalColor = new THREE.Color(color); // Store original color
                sphere.userData.isWarning = false; // Track warning state
                sphere.userData.timeoutId = null;
                sphere.scale.set(0, 0, 0);

                // Ensure we're adding to the correct scene
                this.scene.add(sphere);
                this.spheres.push(sphere);
                
                console.log(`Sphere spawned! Scene children count: ${this.scene.children.length}, Spheres array length: ${this.spheres.length}`);

                new TWEEN.Tween(sphere.scale)
                    .to({x: 1, y: 1, z: 1}, 500)
                    .easing(TWEEN.Easing.Elastic.Out)
                    .start();

                const baseLifetime = 5000;
                const minLifetime = 2000;
                const lifetimeReduction = this.level * 200;
                const lifetime = Math.max(minLifetime, baseLifetime - lifetimeReduction);
                
                sphere.userData.warningTimeoutId = setTimeout(() => {
                    if (this.spheres.includes(sphere) && !this.isGameOver) {
                        // Turn sphere bright red and keep it red
                        sphere.userData.isWarning = true;
                        sphere.material.color.setHex(0xff3333); // Bright, visible red
                        
                        // Add a subtle pulsing scale to make it more noticeable
                        const pulseAnimation = () => {
                            if (this.spheres.includes(sphere) && sphere.userData.isWarning) {
                                new TWEEN.Tween(sphere.scale)
                                    .to({x: 1.1, y: 1.1, z: 1.1}, 400)
                                    .easing(TWEEN.Easing.Quadratic.InOut)
                                    .yoyo(true)
                                    .repeat(1)
                                    .onComplete(() => {
                                        // Continue pulsing if still in warning state
                                        if (this.spheres.includes(sphere) && sphere.userData.isWarning) {
                                            setTimeout(pulseAnimation, 200);
                                        }
                                    })
                                    .start();
                            }
                        };
                        pulseAnimation();
                        
                        console.log('Sphere turned red - warning phase');
                    }
                }, lifetime / 2);

                sphere.userData.timeoutId = setTimeout(() => {
                    if (this.spheres.includes(sphere) && !this.isGameOver) {
                        console.log('Red sphere timed out, removing life');
                        this.missedSphere(sphere);
                    }
                }, lifetime);
            }

            createCubes(position, color) {
                const numCubes = 8;
                // Ensure we use the original color, not the warning red color
                const cubeColor = (typeof color === 'object' && color.getHex) ? color.getHex() : color;
                
                for (let i = 0; i < numCubes; i++) {
                    const angle = (i / numCubes) * Math.PI * 2;
                    const cube = new Cube(this.scene, position, cubeColor);
                    
                    const speed = 0.3;
                    cube.velocity.x = Math.cos(angle) * speed;
                    cube.velocity.y = Math.sin(angle) * speed;
                    
                    this.cubes.push(cube);
                }
                
                console.log(`Created ${numCubes} cubes with color:`, cubeColor);
            }

            popSphere(sphere) {
                if (sphere.userData.timeoutId) {
                    clearTimeout(sphere.userData.timeoutId);
                }
                if (sphere.userData.warningTimeoutId) {
                    clearTimeout(sphere.userData.warningTimeoutId);
                }

                this.spheres = this.spheres.filter(s => s !== sphere);
                this.createCubes(sphere.position.clone(), sphere.userData.color);
                this.updateScore(100);
                
                new TWEEN.Tween(sphere.scale)
                    .to({x: 1.5, y: 1.5, z: 1.5}, 100)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .chain(
                        new TWEEN.Tween(sphere.scale)
                            .to({x: 0, y: 0, z: 0}, 200)
                            .easing(TWEEN.Easing.Quadratic.In)
                    )
                    .start()
                    .onComplete(() => {
                        this.scene.remove(sphere);
                    });
            }

            updateCubes() {
                let cubesToRemove = [];
                let cubesToAutoPop = [];
                
                this.cubes.forEach((cube, index) => {
                    if (!cube.update()) {
                        // Cube fell off screen
                        cubesToRemove.push(index);
                        this.scene.remove(cube.mesh);
                    } else {
                        // Check for paddle collision and get points if hit
                        const points = cube.checkPaddleCollision(this.paddle);
                        if (points > 0) {
                            this.updateScore(points);
                        }
                        
                        // Check if cube should auto-pop at maximum size
                        if (cube.shouldAutoPop()) {
                            cubesToAutoPop.push({
                                index,
                                position: cube.getPosition(),
                                color: cube.getColor()
                            });
                            
                            // Pop animation before removal
                            new TWEEN.Tween(cube.mesh.scale)
                                .to({x: 2, y: 2, z: 2}, 100)
                                .easing(TWEEN.Easing.Quadratic.Out)
                                .chain(
                                    new TWEEN.Tween(cube.mesh.scale)
                                        .to({x: 0, y: 0, z: 0}, 200)
                                        .easing(TWEEN.Easing.Quadratic.In)
                                )
                                .start()
                                .onComplete(() => {
                                    this.scene.remove(cube.mesh);
                                });
                        }
                    }
                });

                // Handle auto-popping cubes - create new cubes like sphere explosion
                cubesToAutoPop.forEach(({ index, position, color }) => {
                    this.updateScore(500); // Higher bonus points for reaching maximum size (8 bounces)
                    this.createCubes(position, color);
                    cubesToRemove.push(index);
                });

                // Remove processed cubes (in reverse order to maintain indices)
                cubesToRemove.sort((a, b) => b - a);
                for (let i of cubesToRemove) {
                    if (this.cubes[i] && this.cubes[i].mesh && this.cubes[i].mesh.parent) {
                        this.scene.remove(this.cubes[i].mesh);
                    }
                    this.cubes.splice(i, 1);
                }
            }

            missedSphere(sphere) {
                if (sphere.userData.timeoutId) {
                    clearTimeout(sphere.userData.timeoutId);
                }
                if (sphere.userData.warningTimeoutId) {
                    clearTimeout(sphere.userData.warningTimeoutId);
                }

                this.spheres = this.spheres.filter(s => s !== sphere);
                
                this.lives--;
                this.updateLivesDisplay();
                
                console.log(`Life lost! Lives remaining: ${this.lives}`);
                
                if (this.lives <= 0) {
                    this.gameOver();
                }
                
                new TWEEN.Tween(sphere.scale)
                    .to({x: 0, y: 0, z: 0}, 300)
                    .easing(TWEEN.Easing.Back.In)
                    .start()
                    .onComplete(() => {
                        this.scene.remove(sphere);
                    });
            }

            updateLivesDisplay() {
                const livesElement = document.querySelector('.lives');
                let livesText = '';
                
                for (let i = 0; i < this.lives; i++) {
                    livesText += '‚ô•';
                }
                
                for (let i = this.lives; i < 4; i++) {
                    livesText += '‚ô°';
                }
                
                livesElement.textContent = livesText;
                
                if (this.lives < 4) {
                    livesElement.classList.add('life-lost');
                    setTimeout(() => {
                        livesElement.classList.remove('life-lost');
                    }, 600);
                }
            }

            updateScore(points) {
                this.score += points;
                document.getElementById('score').textContent = `Score: ${this.score}`;
                
                if (this.score % 1000 === 0) {
                    this.level++;
                    document.getElementById('level').textContent = `Level: ${this.level}`;
                }
            }

            gameOver() {
                this.isGameOver = true;
                document.getElementById('game-over').style.display = 'block';
                clearInterval(this.spawnInterval);
                this.touchManager.clear();
                
                // Clear timeouts first
                this.spheres.forEach(sphere => {
                    if (sphere.userData.timeoutId) {
                        clearTimeout(sphere.userData.timeoutId);
                    }
                    if (sphere.userData.warningTimeoutId) {
                        clearTimeout(sphere.userData.warningTimeoutId);
                    }
                    // Clear warning state to stop any ongoing animations
                    sphere.userData.isWarning = false;
                });
                
                // Clear arrays
                this.spheres.length = 0;
                this.cubes.length = 0;
                
                // Clear any remaining TWEEN animations
                TWEEN.removeAll();
                
                // Create list of objects to preserve
                const preserveObjects = [this.paddle.mesh, ...this.borderTubes];
                
                // Remove everything except preserved objects
                const childrenToRemove = [];
                this.scene.children.forEach(child => {
                    if (!preserveObjects.includes(child)) {
                        childrenToRemove.push(child);
                    }
                });
                
                childrenToRemove.forEach(child => {
                    this.scene.remove(child);
                });
                
                console.log(`Game Over! Removed ${childrenToRemove.length} objects from scene. Preserved: paddle + ${this.borderTubes.length} border tubes.`);
            }

            resetGame() {
                this.score = 0;
                this.level = 1;
                this.lives = 4;
                this.isGameOver = false;
                this.touchManager.clear();
                
                this.spheres.forEach(sphere => {
                    if (sphere.userData.timeoutId) {
                        clearTimeout(sphere.userData.timeoutId);
                    }
                    if (sphere.userData.warningTimeoutId) {
                        clearTimeout(sphere.userData.warningTimeoutId);
                    }
                    this.scene.remove(sphere);
                });
                this.spheres = [];
                
                this.cubes.forEach(cube => this.scene.remove(cube.mesh));
                this.cubes = [];
                
                document.getElementById('score').textContent = 'Score: 0';
                document.getElementById('level').textContent = 'Level: 1';
                document.getElementById('game-over').style.display = 'none';
                this.updateLivesDisplay();
                
                clearInterval(this.spawnInterval);
                this.spawnInterval = setInterval(() => this.spawnSphere(), 3000);
                
                console.log('Game reset!');
            }

            restartGame() {
                console.log('RestartGame called - current scene children:', this.scene.children.length);
                
                // Reset game state without changing mode
                this.score = 0;
                this.level = 1;
                this.lives = 4;
                this.isGameOver = false;
                this.touchManager.clear();
                
                // Clear timeouts first
                this.spheres.forEach(sphere => {
                    if (sphere.userData.timeoutId) {
                        clearTimeout(sphere.userData.timeoutId);
                    }
                    if (sphere.userData.warningTimeoutId) {
                        clearTimeout(sphere.userData.warningTimeoutId);
                    }
                });
                
                // Clear arrays
                this.spheres.length = 0;
                this.cubes.length = 0;
                
                // Clear any remaining TWEEN animations
                TWEEN.removeAll();
                
                // Create list of objects to preserve
                const preserveObjects = [this.paddle.mesh, ...this.borderTubes];
                
                // Remove everything except preserved objects
                const childrenToRemove = [];
                this.scene.children.forEach(child => {
                    if (!preserveObjects.includes(child)) {
                        childrenToRemove.push(child);
                    }
                });
                
                childrenToRemove.forEach(child => {
                    this.scene.remove(child);
                });
                
                console.log(`Cleanup: Removed ${childrenToRemove.length} objects. Scene children now: ${this.scene.children.length}`);
                
                // Reset UI
                document.getElementById('score').textContent = 'Score: 0';
                document.getElementById('level').textContent = 'Level: 1';
                document.getElementById('game-over').style.display = 'none';
                this.updateLivesDisplay();
                
                // Restart spawn interval
                clearInterval(this.spawnInterval);
                this.spawnInterval = setInterval(() => this.spawnSphere(), 3000);
                
                console.log(`${this.mode} game restarted! Scene reference:`, this.scene, 'Renderer reference:', this.renderer);
                
                // Force a render to make sure everything is visible
                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }

            backToMenu() {
                // Clean up current game
                this.isGameOver = true;
                clearInterval(this.spawnInterval);
                this.touchManager.clear();
                
                // Clean up all game objects
                this.spheres.forEach(sphere => {
                    if (sphere.userData.timeoutId) {
                        clearTimeout(sphere.userData.timeoutId);
                    }
                    if (sphere.userData.warningTimeoutId) {
                        clearTimeout(sphere.userData.warningTimeoutId);
                    }
                    if (this.scene) {
                        this.scene.remove(sphere);
                    }
                });
                this.spheres = [];
                
                this.cubes.forEach(cube => {
                    if (this.scene && cube.mesh) {
                        this.scene.remove(cube.mesh);
                    }
                });
                this.cubes = [];
                
                // Safely remove renderer
                if (this.renderer && this.renderer.domElement) {
                    try {
                        if (this.renderer.domElement.parentNode) {
                            this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
                        }
                    } catch (error) {
                        console.log('Renderer cleanup handled:', error.message);
                    }
                }
                
                // Show mode selection
                document.getElementById('mode-selection').style.display = 'flex';
                document.getElementById('game-container').style.display = 'none';
            }

            animate() {
                // Only stop animation if we're truly cleaning up and going back to menu
                if (!this.renderer || !this.scene || !this.camera) {
                    console.log('Animation stopped - missing core objects');
                    return;
                }
                
                requestAnimationFrame(() => this.animate());
                
                try {
                    this.updateCubes();
                    TWEEN.update();
                    this.renderer.render(this.scene, this.camera);
                    
                    // Debug: Periodically log scene state when there should be objects
                    if (this.spheres.length > 0 && Math.random() < 0.01) { // 1% chance per frame
                        console.log(`Animation: ${this.spheres.length} spheres, ${this.cubes.length} cubes, ${this.scene.children.length} scene children`);
                    }
                } catch (error) {
                    console.log('Animation frame handled:', error.message);
                }
            }
        }

        // Mode selection logic
        let currentGame = null;

        document.addEventListener('DOMContentLoaded', () => {
            const modeButtons = document.querySelectorAll('.mode-btn');
            
            modeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const mode = button.dataset.mode;
                    startGame(mode);
                });
            });
        });

        function startGame(mode) {
            document.getElementById('mode-selection').style.display = 'none';
            
            // Clean up any existing game completely
            if (currentGame) {
                try {
                    currentGame.isGameOver = true;
                    if (currentGame.spawnInterval) {
                        clearInterval(currentGame.spawnInterval);
                    }
                    if (currentGame.touchManager) {
                        currentGame.touchManager.clear();
                    }
                    
                    // Clear all game objects
                    if (currentGame.spheres) {
                        currentGame.spheres.forEach(sphere => {
                            if (sphere.userData.timeoutId) clearTimeout(sphere.userData.timeoutId);
                            if (sphere.userData.warningTimeoutId) clearTimeout(sphere.userData.warningTimeoutId);
                            if (currentGame.scene) currentGame.scene.remove(sphere);
                        });
                    }
                    
                    if (currentGame.cubes) {
                        currentGame.cubes.forEach(cube => {
                            if (currentGame.scene && cube.mesh) currentGame.scene.remove(cube.mesh);
                        });
                    }
                    
                    // Remove renderer if it exists
                    if (currentGame.renderer && currentGame.renderer.domElement) {
                        if (currentGame.renderer.domElement.parentNode) {
                            currentGame.renderer.domElement.parentNode.removeChild(currentGame.renderer.domElement);
                        }
                    }
                } catch (error) {
                    console.log('Previous game cleanup handled:', error.message);
                }
                
                // Clear reference
                currentGame = null;
            }
            
            // Reset UI to fresh state
            document.getElementById('score').textContent = 'Score: 0';
            document.getElementById('level').textContent = 'Level: 1';
            document.querySelector('.lives').textContent = '‚ô•‚ô•‚ô•‚ô•';
            document.getElementById('game-over').style.display = 'none';
            
            // Create completely fresh game instance
            currentGame = new Game(mode);
        }
    </script>
</body>
</html>