<!DOCTYPE html>
<html>
<head>
    <title>B2Ply v4 - Bytes To Points (with PCA)</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        #dropZone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            font-size: 24px;
        }

        #instructions {
            position: fixed;
            bottom: 80px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #objectList {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .object-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .delete-btn {
            background: #ff4444;
            border: none;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
        }

        .delete-btn:hover {
            background: #ff6666;
        }

        .visibility-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 2px 6px;
        }

        .export-btn {
            background: #44aaff;
            border: none;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .export-btn:hover {
            background: #66bbff;
        }

        .export-btn.bin {
            background: #aa44ff;
        }

        .export-btn.bin:hover {
            background: #bb66ff;
        }

        .point-size-input {
            width: 60px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 11px;
        }

        .object-info {
            flex-grow: 1;
        }

        .export-buttons {
            display: flex;
            gap: 2px;
        }

        #gridControls {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
        }

        .grid-toggle {
            margin: 5px 0;
            cursor: pointer;
        }

        #fileInput {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }

        #exportButtons {
            position: fixed;
            bottom: 80px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .export-all-btn {
            background: #44cc44;
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            cursor: pointer;
        }

        .export-all-btn:hover {
            background: #66dd66;
        }

        .export-all-btn.bin {
            background: #cc44cc;
        }

        .export-all-btn.bin:hover {
            background: #dd66dd;
        }
        
        /* Thumbnail styles */
        .thumbnail {
            width: 50px;
            height: 50px;
            background-color: #333;
            border: 1px solid #555;
            cursor: pointer;
            object-fit: contain;
        }
        
        /* Image popup styles */
        #imagePopup {
            display: none;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        #popupImage {
            max-width: 90%;
            max-height: 80%;
            border: 2px solid white;
            background-color: #222;
        }
        
        #popupCaption {
            color: white;
            margin-top: 10px;
            font-family: Arial, sans-serif;
        }
        
        #closePopup {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 30px;
            color: white;
            cursor: pointer;
        }

        /* Projection controls */
        #projectionControls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-family: Arial, sans-serif;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            justify-content: center;
        }

        #blendSlider {
            width: 300px;
            height: 6px;
            background: #444;
            outline: none;
            border-radius: 3px;
        }

        #blendSlider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #44aaff;
            border-radius: 50%;
            cursor: pointer;
        }

        #blendSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #44aaff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            font-size: 14px;
            min-width: 80px;
        }

        #quantizationSelect, #projectionSelect {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 3px;
        }

        /* UMAP progress overlay */
        #umapProgress {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            z-index: 1500;
            background: rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(4px);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: Arial, sans-serif;
        }

        .umap-progress-container {
            width: 420px;
            text-align: center;
        }

        .umap-progress-title {
            color: #ccc;
            font-size: 13px;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 18px;
        }

        .umap-progress-phase {
            color: white;
            font-size: 16px;
            margin-bottom: 12px;
        }

        .umap-bar-track {
            width: 100%;
            height: 10px;
            background: #1a1a2e;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }

        .umap-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 5px;
            background: linear-gradient(90deg, #4a00e0, #8e2de2, #00d2ff);
            background-size: 200% 100%;
            animation: umapGradientShift 2s ease infinite;
            position: relative;
            transition: width 0.15s ease-out;
        }

        .umap-bar-fill::after {
            content: '';
            position: absolute;
            right: 0; top: -2px; bottom: -2px;
            width: 20px;
            background: radial-gradient(ellipse at right, rgba(0,210,255,0.7), transparent);
            border-radius: 50%;
            filter: blur(3px);
        }

        @keyframes umapGradientShift {
            0%   { background-position: 0% 50%; }
            50%  { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .umap-progress-detail {
            color: #888;
            font-size: 12px;
            margin-top: 10px;
        }

        .umap-progress-pct {
            color: #00d2ff;
            font-size: 28px;
            font-weight: 300;
            margin-top: 14px;
            font-variant-numeric: tabular-nums;
        }

        .umap-cancel-btn {
            margin-top: 20px;
            background: none;
            border: 1px solid #555;
            color: #999;
            padding: 6px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .umap-cancel-btn:hover {
            border-color: #ff4444;
            color: #ff4444;
        }
    </style>
</head>

<body>
    <div id="dropZone">Drop data or images here</div>
    <div id="instructions">
        Drag and drop files/images to view bytes/rgb as points<br>
        Mouse: Left click + drag to rotate<br>
        Mouse wheel to zoom
    </div>
    <input type="file" id="fileInput" multiple />
    <div id="gridControls">
        <label class="grid-toggle"><input type="checkbox" checked onchange="toggleGrid('xy')"> XY Plane
            (Blue)</label><br>
        <label class="grid-toggle"><input type="checkbox" checked onchange="toggleGrid('xz')"> XZ Plane
            (Red)</label><br>
        <label class="grid-toggle"><input type="checkbox" checked onchange="toggleGrid('yz')"> YZ Plane (Green)</label>
    </div>
    <div id="objectList">
        <h3 style="margin-top: 0">Loaded Objects</h3>
        <div id="objectItems"></div>
    </div>
    <div id="exportButtons">
        <button id="exportAllPlyBtn" class="export-all-btn">Export All as PLY</button>
        <button id="exportAllBinBtn" class="export-all-btn bin">Export All as BIN</button>
    </div>
    
    <!-- Projection controls -->
    <div id="projectionControls">
        <div class="control-group">
            <label class="control-label">Projection:</label>
            <select id="projectionSelect">
                <option value="tiled">Quantized Tiled</option>
                <option value="hilbert">Hilbert Curve</option>
                <option value="morton">Morton Order (Z-order)</option>
                <option value="stereoA">Stereographic A</option>
                <option value="stereoB">Stereographic B</option>
                <option value="fibonacci">Fibonacci Sphere</option>
                <option value="pca">PCA (Data-Driven)</option>
                <option value="umap5">UMAP (5-bit / 32³)</option>
                <option value="umap6">UMAP (6-bit / 64³)</option>
            </select>
        </div>
        <div class="control-group" id="quantizationGroup">
            <label class="control-label">Quantization:</label>
            <select id="quantizationSelect">
                <option value="4">4-bit (16³)</option>
                <option value="5">5-bit (32³)</option>
                <option value="6">6-bit (64³)</option>
                <option value="7">7-bit (128³)</option>
                <option value="8" selected>8-bit (256³)</option>
            </select>
        </div>
        <div class="control-group">
            <label class="control-label">3D ↔ <span id="projectionLabel">Tiled</span>:</label>
            <input type="range" id="blendSlider" min="0" max="1" step="0.01" value="0">
            <span id="blendValue">0%</span>
        </div>
    </div>
    
    <!-- Image popup container -->
    <div id="imagePopup">
        <span id="closePopup">&times;</span>
        <img id="popupImage">
        <div id="popupCaption"></div>
    </div>

    <!-- UMAP progress overlay -->
    <div id="umapProgress">
        <div class="umap-progress-container">
            <div class="umap-progress-title">Hierarchical UMAP</div>
            <div class="umap-progress-phase" id="umapPhase">Initializing…</div>
            <div class="umap-bar-track">
                <div class="umap-bar-fill" id="umapBarFill"></div>
            </div>
            <div class="umap-progress-pct" id="umapPct">0%</div>
            <div class="umap-progress-detail" id="umapDetail"></div>
            <button class="umap-cancel-btn" id="umapCancelBtn">CANCEL</button>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let pointClouds = new Map();
        let objectCounter = 0;
        let grids = {};
        let blendFactor = 0;
        let quantizationBits = 8;
        let currentProjection = 'tiled';

        // Vertex shader for projection morphing
        const vertexShader = `
            attribute vec3 originalPosition;
            attribute vec3 projectedPosition;
            uniform float blendFactor;
            uniform float pointSize;
            varying vec3 vColor;
            
            void main() {
                // Interpolate between original 3D position and projected position
                vec3 position = mix(originalPosition, projectedPosition, blendFactor);
                
                // Pass color to fragment shader (Three.js provides 'color' attribute automatically)
                vColor = color;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = pointSize;
            }
        `;

        // Fragment shader
        const fragmentShader = `
            varying vec3 vColor;
            
            void main() {
                // Use the interpolated vertex color
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 2, 2);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            setupGrids();
            setupDropZone();
            setupExportButtons();
            setupImagePopup();
            setupProjectionControls();
            animate();
        }

        function setupProjectionControls() {
            const blendSlider = document.getElementById('blendSlider');
            const blendValue = document.getElementById('blendValue');
            const quantizationSelect = document.getElementById('quantizationSelect');
            const projectionSelect = document.getElementById('projectionSelect');
            const projectionLabel = document.getElementById('projectionLabel');
            const quantizationGroup = document.getElementById('quantizationGroup');

            blendSlider.addEventListener('input', (e) => {
                blendFactor = parseFloat(e.target.value);
                blendValue.textContent = Math.round(blendFactor * 100) + '%';
                updateAllShaderUniforms();
            });

            quantizationSelect.addEventListener('change', (e) => {
                quantizationBits = parseInt(e.target.value);
                if (currentProjection === 'tiled' || currentProjection === 'hilbert' || currentProjection === 'morton') {
                    // Recalculate positions for projections that use quantization
                    pointClouds.forEach((cloud, id) => {
                        updateProjectedPositions(cloud);
                    });
                }
            });

            projectionSelect.addEventListener('change', (e) => {
                const newProjection = e.target.value;
                if (newProjection !== currentProjection) {
                    currentProjection = newProjection;
                    
                    // Update UI
                    if (currentProjection === 'tiled') {
                        projectionLabel.textContent = 'Tiled';
                        quantizationGroup.style.display = 'flex';
                    } else if (currentProjection === 'hilbert') {
                        projectionLabel.textContent = 'Hilbert';
                        quantizationGroup.style.display = 'flex';
                    } else if (currentProjection === 'morton') {
                        projectionLabel.textContent = 'Morton';
                        quantizationGroup.style.display = 'flex';
                    } else if (currentProjection === 'stereoA') {
                        projectionLabel.textContent = 'Stereo A';
                        quantizationGroup.style.display = 'none';
                    } else if (currentProjection === 'stereoB') {
                        projectionLabel.textContent = 'Stereo B';
                        quantizationGroup.style.display = 'none';
                    } else if (currentProjection === 'fibonacci') {
                        projectionLabel.textContent = 'Fibonacci';
                        quantizationGroup.style.display = 'none';
                    } else if (currentProjection === 'pca') {
                        projectionLabel.textContent = 'PCA';
                        quantizationGroup.style.display = 'none';
                    } else if (currentProjection === 'umap5' || currentProjection === 'umap6') {
                        const bits = currentProjection === 'umap5' ? 5 : 6;
                        projectionLabel.textContent = `UMAP ${bits}-bit`;
                        quantizationGroup.style.display = 'none';
                        // Trigger UMAP computation for all loaded clouds
                        triggerUMAPForAllClouds(bits);
                        return; // Don't update positions yet — worker will do it
                    }
                    
                    // Recalculate projected positions for all point clouds
                    pointClouds.forEach((cloud, id) => {
                        updateProjectedPositions(cloud);
                    });
                }
            });
        }

        function updateAllShaderUniforms() {
            pointClouds.forEach(cloud => {
                if (cloud.object.material.uniforms) {
                    cloud.object.material.uniforms.blendFactor.value = blendFactor;
                }
            });
        }

        function calculateTiledProjection(points, quantizationBits) {
            const q = quantizationBits;
            const qRange = Math.pow(2, q);
            const sqrtQRange = Math.floor(Math.sqrt(qRange));
            const maxTiledCoord = Math.max(sqrtQRange * qRange + qRange - 1, 1);
            
            // Create new projected points array
            const projectedPoints = new Float32Array(points.length);
            
            for (let i = 0; i < points.length; i += 3) {
                const x = points[i];
                const y = points[i + 1];
                const z = points[i + 2];
                
                // Convert normalized coordinates [-1,1] to discrete grid [0, qRange-1]
                const discreteX = Math.max(0, Math.min(qRange - 1, Math.floor((x + 1) / 2 * qRange)));
                const discreteY = Math.max(0, Math.min(qRange - 1, Math.floor((y + 1) / 2 * qRange)));
                const discreteZ = Math.max(0, Math.min(qRange - 1, Math.floor((z + 1) / 2 * qRange)));
                
                // Apply tiling formula: (col, row) = (z % sqrt(2^q), floor(z / sqrt(2^q)))
                const col = discreteZ % sqrtQRange;
                const row = Math.floor(discreteZ / sqrtQRange);
                
                // Calculate tiled coordinates: col * 2^q + x, row * 2^q + y
                const tiledX = col * qRange + discreteX;
                const tiledY = row * qRange + discreteY;
                
                // Normalize back for display (scale to fit in reasonable viewing area)
                projectedPoints[i] = (tiledX / maxTiledCoord) * 2 - 1;
                projectedPoints[i + 1] = (tiledY / maxTiledCoord) * 2 - 1;
                projectedPoints[i + 2] = 0; // Flatten to z=0 plane
            }
            
            return projectedPoints;
        }

        // 3D Hilbert curve encoding - converts (x,y,z) coordinates to index along curve
        function xyz2hilbert(x, y, z, order) {
            let index = 0;
            let rx, ry, rz;
            
            for (let i = order - 1; i >= 0; i--) {
                const mask = 1 << i;
                rx = (x & mask) ? 1 : 0;
                ry = (y & mask) ? 1 : 0;
                rz = (z & mask) ? 1 : 0;
                
                // Convert 3-bit position to index (0-7)
                const position = (rx << 2) | (ry << 1) | rz;
                
                // Add contribution of this level (shift by 3 bits for octree)
                index = (index << 3) | position;
                
                // Apply rotation for next level
                const coords = rotateHilbertCoords(rx, ry, rz, position);
                if (coords.flipX) x ^= mask;
                if (coords.flipY) y ^= mask;
                if (coords.flipZ) z ^= mask;
            }
            
            return index;
        }

        // Rotation logic for 3D Hilbert curve to maintain space-filling property
        function rotateHilbertCoords(x, y, z, state) {
            // Simplified rotation table for 3D Hilbert curve
            // These flips help maintain locality through the curve
            const rotations = [
                {flipX: false, flipY: false, flipZ: false}, // 000
                {flipX: false, flipY: false, flipZ: true},  // 001
                {flipX: false, flipY: true, flipZ: true},   // 010
                {flipX: false, flipY: true, flipZ: false},  // 011
                {flipX: true, flipY: true, flipZ: false},   // 100
                {flipX: true, flipY: true, flipZ: true},    // 101
                {flipX: true, flipY: false, flipZ: true},   // 110
                {flipX: true, flipY: false, flipZ: false}   // 111
            ];
            return rotations[state];
        }

        function calculateHilbertProjection(points, quantizationBits) {
            const projectedPoints = new Float32Array(points.length);
            const q = quantizationBits;
            const qRange = Math.pow(2, q);
            const totalCells = Math.pow(qRange, 3);
            const width = Math.ceil(Math.sqrt(totalCells));
            
            for (let i = 0; i < points.length; i += 3) {
                const x = points[i];
                const y = points[i + 1];
                const z = points[i + 2];
                
                // Convert normalized coordinates [-1,1] to discrete grid [0, qRange-1]
                const discreteX = Math.max(0, Math.min(qRange - 1, Math.floor((x + 1) / 2 * qRange)));
                const discreteY = Math.max(0, Math.min(qRange - 1, Math.floor((y + 1) / 2 * qRange)));
                const discreteZ = Math.max(0, Math.min(qRange - 1, Math.floor((z + 1) / 2 * qRange)));
                
                // Convert 3D position to Hilbert index
                const hilbertIndex = xyz2hilbert(discreteX, discreteY, discreteZ, q);
                
                // Convert 1D Hilbert index to 2D position (serpentine layout)
                const col = hilbertIndex % width;
                const row = Math.floor(hilbertIndex / width);
                
                // Normalize back to [-1, 1] range for display
                projectedPoints[i] = (col / width) * 2 - 1;
                projectedPoints[i + 1] = (row / width) * 2 - 1;
                projectedPoints[i + 2] = 0; // Flatten to z=0 plane
            }
            
            return projectedPoints;
        }

        // Morton order (Z-order curve) encoding - interleaves bits of x, y, z coordinates
        function xyz2morton(x, y, z) {
            let morton = 0;
            
            // Interleave bits: for each bit position, add z bit, then y bit, then x bit
            for (let i = 0; i < 32; i++) {
                morton |= ((x & (1 << i)) << (2 * i)) |
                          ((y & (1 << i)) << (2 * i + 1)) |
                          ((z & (1 << i)) << (2 * i + 2));
            }
            
            return morton;
        }

        function calculateMortonProjection(points, quantizationBits) {
            const projectedPoints = new Float32Array(points.length);
            const q = quantizationBits;
            const qRange = Math.pow(2, q);
            const totalCells = Math.pow(qRange, 3);
            const width = Math.ceil(Math.sqrt(totalCells));
            
            for (let i = 0; i < points.length; i += 3) {
                const x = points[i];
                const y = points[i + 1];
                const z = points[i + 2];
                
                // Convert normalized coordinates [-1,1] to discrete grid [0, qRange-1]
                const discreteX = Math.max(0, Math.min(qRange - 1, Math.floor((x + 1) / 2 * qRange)));
                const discreteY = Math.max(0, Math.min(qRange - 1, Math.floor((y + 1) / 2 * qRange)));
                const discreteZ = Math.max(0, Math.min(qRange - 1, Math.floor((z + 1) / 2 * qRange)));
                
                // Convert 3D position to Morton index
                const mortonIndex = xyz2morton(discreteX, discreteY, discreteZ);
                
                // Convert 1D Morton index to 2D position (serpentine layout)
                const col = mortonIndex % width;
                const row = Math.floor(mortonIndex / width);
                
                // Normalize back to [-1, 1] range for display
                projectedPoints[i] = (col / width) * 2 - 1;
                projectedPoints[i + 1] = (row / width) * 2 - 1;
                projectedPoints[i + 2] = 0; // Flatten to z=0 plane
            }
            
            return projectedPoints;
        }

        function calculateStereographicProjection(points, variant = 'A') {
            const projectedPoints = new Float32Array(points.length);
            
            for (let i = 0; i < points.length; i += 3) {
                const x = points[i];
                const y = points[i + 1];
                const z = points[i + 2];
                
                // First normalize the point to unit sphere
                const length = Math.sqrt(x * x + y * y + z * z);
                if (length === 0) {
                    projectedPoints[i] = 0;
                    projectedPoints[i + 1] = 0;
                    projectedPoints[i + 2] = 0;
                    continue;
                }
                
                const nx = x / length;
                const ny = y / length;
                const nz = z / length;
                
                let projX, projY, scale;
                
                if (variant === 'A') {
                    // s2cA: p.xy / (0.5 - p.z)
                    const denom = 0.5 - nz;
                    if (Math.abs(denom) < 0.001) {
                        projX = nx * 200;
                        projY = ny * 200;
                    } else {
                        projX = nx / denom;
                        projY = ny / denom;
                    }
                    scale = 0.08; // Adjusted for s2cA characteristics
                } else {
                    // s2cB: p.xy / (1.0 - p.z)
                    const denom = 1.0 - nz;
                    if (Math.abs(denom) < 0.001) {
                        projX = nx * 100;
                        projY = ny * 100;
                    } else {
                        projX = nx / denom;
                        projY = ny / denom;
                    }
                    scale = 0.15; // Adjusted for s2cB characteristics
                }
                
                projectedPoints[i] = projX * scale;
                projectedPoints[i + 1] = projY * scale;
                projectedPoints[i + 2] = 0; // Flatten to z=0 plane
            }
            
            return projectedPoints;
        }

        function calculateFibonacciSphere(points) {
            const projectedPoints = new Float32Array(points.length);
            const numPoints = points.length / 3;
            
            // Golden angle in radians
            const goldenAngle = Math.PI * (3.0 - Math.sqrt(5.0));
            
            for (let i = 0; i < numPoints; i++) {
                const pointIndex = i * 3;
                
                // Fibonacci sphere algorithm
                const y = 1 - (i / (numPoints - 1)) * 2; // y goes from 1 to -1
                const radius = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;
                
                projectedPoints[pointIndex] = x;
                projectedPoints[pointIndex + 1] = y;
                projectedPoints[pointIndex + 2] = z;
            }
            
            return projectedPoints;
        }

        function calculatePCAProjection(points) {
            const numPoints = points.length / 3;
            const projectedPoints = new Float32Array(points.length);
            
            if (numPoints < 2) {
                return projectedPoints;
            }
            
            // Step 1: Calculate mean (centroid)
            let meanX = 0, meanY = 0, meanZ = 0;
            for (let i = 0; i < points.length; i += 3) {
                meanX += points[i];
                meanY += points[i + 1];
                meanZ += points[i + 2];
            }
            meanX /= numPoints;
            meanY /= numPoints;
            meanZ /= numPoints;
            
            // Step 2: Calculate covariance matrix (3x3 symmetric)
            // Cov = [xx, xy, xz]
            //       [xy, yy, yz]
            //       [xz, yz, zz]
            let cxx = 0, cxy = 0, cxz = 0;
            let cyy = 0, cyz = 0, czz = 0;
            
            for (let i = 0; i < points.length; i += 3) {
                const dx = points[i] - meanX;
                const dy = points[i + 1] - meanY;
                const dz = points[i + 2] - meanZ;
                
                cxx += dx * dx;
                cxy += dx * dy;
                cxz += dx * dz;
                cyy += dy * dy;
                cyz += dy * dz;
                czz += dz * dz;
            }
            
            // Normalize by n-1 for sample covariance
            const n = numPoints - 1;
            cxx /= n; cxy /= n; cxz /= n;
            cyy /= n; cyz /= n; czz /= n;
            
            // Step 3: Find eigenvectors using power iteration
            // We need the two largest eigenvectors for 2D projection
            const eigenvectors = computeTopTwoEigenvectors(cxx, cxy, cxz, cyy, cyz, czz);
            
            // Step 4: Project points onto the two principal components
            let minU = Infinity, maxU = -Infinity;
            let minV = Infinity, maxV = -Infinity;
            
            const projected2D = new Float32Array(numPoints * 2);
            
            for (let i = 0; i < numPoints; i++) {
                const idx = i * 3;
                const dx = points[idx] - meanX;
                const dy = points[idx + 1] - meanY;
                const dz = points[idx + 2] - meanZ;
                
                // Project onto first eigenvector (PC1)
                const u = dx * eigenvectors.pc1[0] + dy * eigenvectors.pc1[1] + dz * eigenvectors.pc1[2];
                // Project onto second eigenvector (PC2)
                const v = dx * eigenvectors.pc2[0] + dy * eigenvectors.pc2[1] + dz * eigenvectors.pc2[2];
                
                projected2D[i * 2] = u;
                projected2D[i * 2 + 1] = v;
                
                minU = Math.min(minU, u);
                maxU = Math.max(maxU, u);
                minV = Math.min(minV, v);
                maxV = Math.max(maxV, v);
            }
            
            // Step 5: Normalize to [-1, 1] range
            const rangeU = maxU - minU || 1;
            const rangeV = maxV - minV || 1;
            const scale = Math.max(rangeU, rangeV) / 2;
            
            for (let i = 0; i < numPoints; i++) {
                const idx = i * 3;
                const u = projected2D[i * 2];
                const v = projected2D[i * 2 + 1];
                
                projectedPoints[idx] = u / scale;
                projectedPoints[idx + 1] = v / scale;
                projectedPoints[idx + 2] = 0; // Flatten to z=0 plane
            }
            
            return projectedPoints;
        }

        function computeTopTwoEigenvectors(cxx, cxy, cxz, cyy, cyz, czz) {
            // Power iteration to find dominant eigenvector
            // Then deflation to find second eigenvector
            
            const maxIterations = 100;
            const tolerance = 1e-10;
            
            // Helper: multiply covariance matrix by vector
            function matVecMul(vx, vy, vz) {
                return [
                    cxx * vx + cxy * vy + cxz * vz,
                    cxy * vx + cyy * vy + cyz * vz,
                    cxz * vx + cyz * vy + czz * vz
                ];
            }
            
            // Helper: normalize vector
            function normalize(v) {
                const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                if (len < 1e-10) return [1, 0, 0];
                return [v[0] / len, v[1] / len, v[2] / len];
            }
            
            // Find first eigenvector (largest eigenvalue)
            let pc1 = [1, 0, 0]; // Initial guess
            let eigenvalue1 = 0;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                const newVec = matVecMul(pc1[0], pc1[1], pc1[2]);
                const newLen = Math.sqrt(newVec[0] * newVec[0] + newVec[1] * newVec[1] + newVec[2] * newVec[2]);
                
                if (Math.abs(newLen - eigenvalue1) < tolerance) break;
                
                eigenvalue1 = newLen;
                pc1 = normalize(newVec);
            }
            
            // Deflate the matrix: C' = C - λ1 * v1 * v1^T
            const deflatedCxx = cxx - eigenvalue1 * pc1[0] * pc1[0];
            const deflatedCxy = cxy - eigenvalue1 * pc1[0] * pc1[1];
            const deflatedCxz = cxz - eigenvalue1 * pc1[0] * pc1[2];
            const deflatedCyy = cyy - eigenvalue1 * pc1[1] * pc1[1];
            const deflatedCyz = cyz - eigenvalue1 * pc1[1] * pc1[2];
            const deflatedCzz = czz - eigenvalue1 * pc1[2] * pc1[2];
            
            // Helper for deflated matrix
            function deflatedMatVecMul(vx, vy, vz) {
                return [
                    deflatedCxx * vx + deflatedCxy * vy + deflatedCxz * vz,
                    deflatedCxy * vx + deflatedCyy * vy + deflatedCyz * vz,
                    deflatedCxz * vx + deflatedCyz * vy + deflatedCzz * vz
                ];
            }
            
            // Find second eigenvector
            // Start with vector orthogonal to pc1
            let pc2 = Math.abs(pc1[0]) < 0.9 ? [1, 0, 0] : [0, 1, 0];
            // Gram-Schmidt orthogonalization
            const dot = pc2[0] * pc1[0] + pc2[1] * pc1[1] + pc2[2] * pc1[2];
            pc2 = normalize([pc2[0] - dot * pc1[0], pc2[1] - dot * pc1[1], pc2[2] - dot * pc1[2]]);
            
            for (let iter = 0; iter < maxIterations; iter++) {
                const newVec = deflatedMatVecMul(pc2[0], pc2[1], pc2[2]);
                const newNorm = normalize(newVec);
                
                // Ensure orthogonality to pc1
                const d = newNorm[0] * pc1[0] + newNorm[1] * pc1[1] + newNorm[2] * pc1[2];
                pc2 = normalize([newNorm[0] - d * pc1[0], newNorm[1] - d * pc1[1], newNorm[2] - d * pc1[2]]);
            }
            
            return { pc1, pc2 };
        }

        function updateProjectedPositions(cloud) {
            const originalPositions = cloud.originalPositions;
            let projectedPositions;
            
            if (currentProjection === 'tiled') {
                projectedPositions = calculateTiledProjection(originalPositions, quantizationBits);
            } else if (currentProjection === 'hilbert') {
                projectedPositions = calculateHilbertProjection(originalPositions, quantizationBits);
            } else if (currentProjection === 'morton') {
                projectedPositions = calculateMortonProjection(originalPositions, quantizationBits);
            } else if (currentProjection === 'stereoA') {
                projectedPositions = calculateStereographicProjection(originalPositions, 'A');
            } else if (currentProjection === 'stereoB') {
                projectedPositions = calculateStereographicProjection(originalPositions, 'B');
            } else if (currentProjection === 'fibonacci') {
                projectedPositions = calculateFibonacciSphere(originalPositions);
            } else if (currentProjection === 'pca') {
                projectedPositions = calculatePCAProjection(originalPositions);
            } else if (currentProjection === 'umap5' || currentProjection === 'umap6') {
                // UMAP positions are set asynchronously by the worker
                // If we have cached results, use them; otherwise skip
                if (cloud.umapProjectedPositions) {
                    projectedPositions = cloud.umapProjectedPositions;
                } else {
                    return; // Worker hasn't finished yet
                }
            }
            
            cloud.object.geometry.setAttribute('projectedPosition', new THREE.Float32BufferAttribute(projectedPositions, 3));
        }

        function setupGrids() {
            const gridSize = 2;  // Reduced grid size to match normalized data
            const gridDivisions = 4;  // More divisions for finer reference

            // XY Plane (Blue)
            const gridXY = new THREE.GridHelper(gridSize, gridDivisions, 0x0000ff, 0x0000ff);
            gridXY.rotation.x = Math.PI / 2;
            scene.add(gridXY);
            grids.xy = gridXY;

            // XZ Plane (Red)
            const gridXZ = new THREE.GridHelper(gridSize, gridDivisions, 0xff0000, 0xff0000);
            scene.add(gridXZ);
            grids.xz = gridXZ;

            // YZ Plane (Green)
            const gridYZ = new THREE.GridHelper(gridSize, gridDivisions, 0x00ff00, 0x00ff00);
            gridYZ.rotation.z = Math.PI / 2;
            scene.add(gridYZ);
            grids.yz = gridYZ;
        }

        function toggleGrid(plane) {
            if (grids[plane]) {
                grids[plane].visible = !grids[plane].visible;
            }
        }

        function removeAlphaChannel(canvas, data) {
            const imagePixelCount = canvas.width * canvas.height;
            const rgbOnlyBytes = new Uint8ClampedArray(imagePixelCount * 3);
            let nextImageIdx = 0;
            let nextRGBIdx = 0;
            for (let i = 0; i < imagePixelCount; i++) {
                rgbOnlyBytes[nextRGBIdx] = data[nextImageIdx];
                rgbOnlyBytes[nextRGBIdx + 1] = data[nextImageIdx + 1];
                rgbOnlyBytes[nextRGBIdx + 2] = data[nextImageIdx + 2];
                nextImageIdx += 4;
                nextRGBIdx += 3;
            }
            return rgbOnlyBytes;
        }

        function handleFiles(files) {
            for (const file of files) {
                const reader = new FileReader();

                reader.onload = function (e) {
                    if (file.type.startsWith('image/')) {
                        const img = new Image();
                        img.onload = function () {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            createPointCloud(removeAlphaChannel(canvas, imageData.data), file.name);
                        };
                        img.src = e.target.result;
                    } else {
                        const arrayBuffer = e.target.result;
                        const uint8Array = new Uint8Array(arrayBuffer);
                        createPointCloud(uint8Array, file.name);
                    }
                };

                if (file.type.startsWith('image/')) {
                    reader.readAsDataURL(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            }
        }

        // Handle clipboard operations
        document.addEventListener('paste', (e) => {
            e.preventDefault();
            const items = (e.clipboardData || window.clipboardData).items;
            for (let item of items) {
                if (item.kind === 'file') {
                    const file = item.getAsFile();
                    handleFiles([file]);
                } else {
                  item.getAsString( (text) => {
                    tryFetchAPI(text);
                  } );
                }
            }
        });

        async function tryFetchAPI(src) {
            try {
                const response = await fetch(src);
                if (response.ok) {
                    handleFiles([await response.blob()]);
                }
            } catch (_) {
            }
        }

        function handleNonFileDrop(text) {
            if (text.startsWith('<meta')) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/html');
                    const imgSrc = doc.querySelector('img').getAttribute('src');
                    tryFetchAPI(imgSrc);
                } catch (_) {
                }
            }
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const file = dt.files[0];

            if (file) {
                handleFiles(e.dataTransfer.files);
                return;
            }

            for (let i = 0; i < dt.items.length; i++) {
                const item = dt.items[i];
                if (!(item.kind === 'string')) continue;
                item.getAsString((s) => {
                    handleNonFileDrop(s);
                });
            }
        }

        function setupDropZone() {
            const dropZone = document.getElementById('dropZone');

            document.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dropZone.style.display = 'flex';
            });

            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropZone.style.display = 'none';
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.display = 'none';
                handleDrop(e);
            });
        }

        function getUniqueTuples(data) {
            const bitArraySizeInUint32 = Math.ceil((256 * 256 * 256) / 32);
            const tupleBitArray = new Uint32Array(bitArraySizeInUint32);
            const resultTuples = [];

            for (let i = 0; i < data.length; i += 3) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                const index = (r << 16) | (g << 8) | b;
                const elementIndex = index >> 5;
                const bitPosition = index & 0x1F;
                const mask = 1 << bitPosition;

                if ((tupleBitArray[elementIndex] & mask) === 0) {
                    tupleBitArray[elementIndex] |= mask;
                    resultTuples.push(r, g, b);
                }
            }

            return resultTuples;
        }
        
        function createThumbnailImage(rgbData) {
            // Calculate optimal dimensions for a square image
            const pointCount = rgbData.length / 3;
            const side = Math.ceil(Math.sqrt(pointCount));
            
            // Create canvas and get context
            const canvas = document.createElement('canvas');
            canvas.width = side;
            canvas.height = side;
            const ctx = canvas.getContext('2d');
            
            // Fill with black background
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, side, side);
            
            // Create ImageData to draw the points
            const imageData = ctx.createImageData(side, side);
            const data = imageData.data;
            
            // Fill data with transparent black
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 0;     // R
                data[i+1] = 0;   // G
                data[i+2] = 0;   // B
                data[i+3] = 0;   // A - transparent
            }
            
            // Add points to the image
            for (let i = 0; i < pointCount && i < side * side; i++) {
                const x = i % side;
                const y = Math.floor(i / side);
                const pixelIndex = (y * side + x) * 4;
                
                const pointIndex = i * 3;
                data[pixelIndex] = rgbData[pointIndex];       // R
                data[pixelIndex+1] = rgbData[pointIndex+1];   // G
                data[pixelIndex+2] = rgbData[pointIndex+2];   // B
                data[pixelIndex+3] = 255;                     // A - fully opaque
            }
            
            // Put the image data on the canvas
            ctx.putImageData(imageData, 0, 0);
            
            return {
                dataUrl: canvas.toDataURL('image/png'),
                width: side,
                height: side
            };
        }

        function createPointCloud(buffer, fileName) {
            const inputByteCount = buffer.length;
            const inputTupleCount = Math.floor(inputByteCount / 3);
            
            const rgbData = new Uint8Array(getUniqueTuples(buffer));
            const pointCount = Math.floor(rgbData.length / 3);
            
            console.log(`Importing "${fileName}": ${inputByteCount} bytes (${inputTupleCount} tuples) → ${pointCount} unique points`);
            
            const vertices = new Float32Array(pointCount * 3);

            for (let i = 0; i < pointCount; i++) {
                const rgbIndex = i * 3;
                const vertexIndex = i * 3;

                // Convert RGB values to normalized coordinates (-1 to 1)
                const x = (rgbData[rgbIndex] / 255) * 2 - 1;
                const y = (rgbData[rgbIndex + 1] / 255) * 2 - 1;
                const z = (rgbData[rgbIndex + 2] / 255) * 2 - 1;

                vertices[vertexIndex] = x;
                vertices[vertexIndex + 1] = y;
                vertices[vertexIndex + 2] = z;
            }

            // Calculate projected positions based on current projection
            let projectedPositions;
            if (currentProjection === 'tiled') {
                projectedPositions = calculateTiledProjection(vertices, quantizationBits);
            } else if (currentProjection === 'hilbert') {
                projectedPositions = calculateHilbertProjection(vertices, quantizationBits);
            } else if (currentProjection === 'morton') {
                projectedPositions = calculateMortonProjection(vertices, quantizationBits);
            } else if (currentProjection === 'stereoA') {
                projectedPositions = calculateStereographicProjection(vertices, 'A');
            } else if (currentProjection === 'stereoB') {
                projectedPositions = calculateStereographicProjection(vertices, 'B');
            } else if (currentProjection === 'fibonacci') {
                projectedPositions = calculateFibonacciSphere(vertices);
            } else if (currentProjection === 'pca') {
                projectedPositions = calculatePCAProjection(vertices);
            } else if (currentProjection === 'umap5' || currentProjection === 'umap6') {
                // Use tiled as placeholder until UMAP recomputes
                projectedPositions = calculateTiledProjection(vertices, quantizationBits);
            }

            // Create the 2D thumbnail image
            const thumbnail = createThumbnailImage(rgbData);

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('originalPosition', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('projectedPosition', new THREE.Float32BufferAttribute(projectedPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(rgbData, 3, true));

            // Create shader material
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    blendFactor: { value: blendFactor },
                    pointSize: { value: 0.005 * Math.max(window.innerWidth, window.innerHeight) / 100 }
                },
                vertexColors: true
            });

            const points = new THREE.Points(geometry, material);

            const id = `cloud_${objectCounter++}`;
            pointClouds.set(id, {
                object: points,
                name: fileName || 'unknown',
                pointCount: pointCount,
                thumbnail: thumbnail,
                originalPositions: vertices,
                pointSizeBase: 0.005
            });

            scene.add(points);
            updateObjectList();
        }

        function setupImagePopup() {
            const popup = document.getElementById('imagePopup');
            const closeBtn = document.getElementById('closePopup');
            
            // Close popup when clicking the X
            closeBtn.addEventListener('click', () => {
                popup.style.display = 'none';
            });
            
            // Close popup when clicking outside the image
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    popup.style.display = 'none';
                }
            });
            
            // Close popup with Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && popup.style.display === 'flex') {
                    popup.style.display = 'none';
                }
            });
        }
        
        function showImagePopup(id) {
            const cloud = pointClouds.get(id);
            if (!cloud || !cloud.thumbnail) return;
            
            const popup = document.getElementById('imagePopup');
            const img = document.getElementById('popupImage');
            const caption = document.getElementById('popupCaption');
            
            img.src = cloud.thumbnail.dataUrl;
            caption.textContent = `${cloud.name}: ${cloud.pointCount.toLocaleString()} unique points (${cloud.thumbnail.width}×${cloud.thumbnail.height})`;
            
            popup.style.display = 'flex';
        }

        function updateObjectList() {
            const container = document.getElementById('objectItems');
            container.innerHTML = '';

            pointClouds.forEach((cloud, id) => {
                const item = document.createElement('div');
                item.className = 'object-item';

                // Create thumbnail if available
                if (cloud.thumbnail) {
                    const thumb = document.createElement('img');
                    thumb.className = 'thumbnail';
                    thumb.src = cloud.thumbnail.dataUrl;
                    thumb.title = 'Click to view full image';
                    thumb.onclick = () => showImagePopup(id);
                    item.appendChild(thumb);
                }

                const info = document.createElement('div');
                info.className = 'object-info';
                info.textContent = `${cloud.name} (${cloud.pointCount.toLocaleString()} points)`;

                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'visibility-btn';
                visibilityBtn.innerHTML = cloud.object.visible ? '👁️' : '👁️‍🗨️';
                visibilityBtn.onclick = () => toggleVisibility(id);

                const exportButtons = document.createElement('div');
                exportButtons.className = 'export-buttons';

                const exportPlyBtn = document.createElement('button');
                exportPlyBtn.className = 'export-btn';
                exportPlyBtn.textContent = 'PLY';
                exportPlyBtn.title = 'Export as PLY';
                exportPlyBtn.onclick = () => exportAsPLY(id);

                const exportBinBtn = document.createElement('button');
                exportBinBtn.className = 'export-btn bin';
                exportBinBtn.textContent = 'BIN';
                exportBinBtn.title = 'Export as binary (signed 8-bit)';
                exportBinBtn.onclick = () => exportAsBIN(id);

                exportButtons.appendChild(exportPlyBtn);
                exportButtons.appendChild(exportBinBtn);

                const sizeInput = document.createElement('input');
                sizeInput.type = 'number';
                sizeInput.className = 'point-size-input';
                sizeInput.min = '0.005';
                sizeInput.max = '0.5';
                sizeInput.step = '0.005';
                sizeInput.value = cloud.pointSizeBase;
                sizeInput.title = 'Point size (0.005 - 0.5)';
                sizeInput.onchange = (e) => updatePointSize(id, parseFloat(e.target.value));

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = '×';
                deleteBtn.onclick = () => deletePointCloud(id);

                item.appendChild(info);
                item.appendChild(visibilityBtn);
                item.appendChild(exportButtons);
                item.appendChild(sizeInput);
                item.appendChild(deleteBtn);
                container.appendChild(item);
            });
        }

        function toggleVisibility(id) {
            const cloud = pointClouds.get(id);
            if (cloud) {
                cloud.object.visible = !cloud.object.visible;
                updateObjectList();
            }
        }

        function updatePointSize(id, value) {
            const cloud = pointClouds.get(id);
            if (cloud) {
                value = Math.max(0.005, Math.min(0.5, value || 0.005));
                cloud.pointSizeBase = value;
                if (cloud.object.material.uniforms) {
                    cloud.object.material.uniforms.pointSize.value = value * Math.max(window.innerWidth, window.innerHeight) / 100;
                }
            }
        }

        function deletePointCloud(id) {
            const cloud = pointClouds.get(id);
            if (cloud) {
                scene.remove(cloud.object);
                pointClouds.delete(id);
                updateObjectList();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        function setupExportButtons() {
            document.getElementById('exportAllPlyBtn').addEventListener('click', exportAllVisibleAsPLY);
            document.getElementById('exportAllBinBtn').addEventListener('click', exportAllVisibleAsBIN);
        }

        function exportAsPLY(id) {
            const cloud = pointClouds.get(id);
            if (cloud) {
                const plyData = generatePLY(cloud.object);
                const filename = cloud.name.replace(/\.[^/.]+$/, "") + ".ply";
                downloadText(plyData, filename, 'application/octet-stream');
            }
        }

        function exportAsBIN(id) {
            const cloud = pointClouds.get(id);
            if (cloud) {
                const binData = generateBIN(cloud.object);
                const filename = cloud.name.replace(/\.[^/.]+$/, "") + ".bin";
                downloadBlob(binData, filename, 'application/octet-stream');
            }
        }

        function exportAllVisibleAsPLY() {
            // Count total points in all visible point clouds
            let totalPoints = 0;
            const visibleClouds = [];

            pointClouds.forEach(cloud => {
                if (cloud.object.visible) {
                    totalPoints += cloud.pointCount;
                    visibleClouds.push(cloud);
                }
            });

            if (visibleClouds.length === 0) {
                console.log('No visible point clouds to export');
                return;
            }

            // Generate combined PLY data
            const plyData = generateCombinedPLY(visibleClouds, totalPoints);
            downloadText(plyData, 'b2p_combined_export.ply', 'application/octet-stream');
        }

        function exportAllVisibleAsBIN() {
            // Count total points in all visible point clouds
            let totalPoints = 0;
            const visibleClouds = [];

            pointClouds.forEach(cloud => {
                if (cloud.object.visible) {
                    totalPoints += cloud.pointCount;
                    visibleClouds.push(cloud);
                }
            });

            if (visibleClouds.length === 0) {
                console.log('No visible point clouds to export');
                return;
            }

            // Generate combined BIN data
            const binData = generateCombinedBIN(visibleClouds, totalPoints);
            downloadBlob(binData, 'b2p_combined_export.bin', 'application/octet-stream');
        }

        function convertFloatToInt8(value) {
            // Convert from normalized float (-1 to 1) to signed 8-bit (-128 to 127)
            // Clamp the value to ensure it's within range
            const clamped = Math.max(-1, Math.min(1, value));
            const scaled = clamped * 127;
            return Math.round(scaled);
        }

        function generateBIN(pointCloud) {
            const originalPositions = pointCloud.geometry.getAttribute('originalPosition');
            const projectedPositions = pointCloud.geometry.getAttribute('projectedPosition');
            const pointCount = originalPositions.count;
            
            console.log(`Exporting BIN: ${pointCount} points, blendFactor: ${blendFactor}`);
            
            // Create binary data array: 3 bytes per point (x, y, z as signed 8-bit)
            const binaryData = new Int8Array(pointCount * 3);
            
            for (let i = 0; i < pointCount; i++) {
                // Interpolate between original and projected based on blendFactor
                const x = originalPositions.getX(i) * (1 - blendFactor) + projectedPositions.getX(i) * blendFactor;
                const y = originalPositions.getY(i) * (1 - blendFactor) + projectedPositions.getY(i) * blendFactor;
                const z = originalPositions.getZ(i) * (1 - blendFactor) + projectedPositions.getZ(i) * blendFactor;
                
                const baseIndex = i * 3;
                binaryData[baseIndex] = convertFloatToInt8(x);
                binaryData[baseIndex + 1] = convertFloatToInt8(y);
                binaryData[baseIndex + 2] = convertFloatToInt8(z);
            }
            
            console.log(`BIN export complete: ${binaryData.byteLength} bytes`);
            return binaryData.buffer;
        }

        function generateCombinedBIN(clouds, totalPoints) {
            console.log(`Exporting Combined BIN: ${totalPoints} points, blendFactor: ${blendFactor}`);
            
            // Create binary data array for all visible clouds
            const binaryData = new Int8Array(totalPoints * 3);
            let currentIndex = 0;
            
            for (const cloud of clouds) {
                if (cloud.object.visible) {
                    const originalPositions = cloud.object.geometry.getAttribute('originalPosition');
                    const projectedPositions = cloud.object.geometry.getAttribute('projectedPosition');
                    
                    console.log(`  - ${cloud.name}: ${originalPositions.count} points`);
                    
                    for (let i = 0; i < originalPositions.count; i++) {
                        // Interpolate between original and projected based on blendFactor
                        const x = originalPositions.getX(i) * (1 - blendFactor) + projectedPositions.getX(i) * blendFactor;
                        const y = originalPositions.getY(i) * (1 - blendFactor) + projectedPositions.getY(i) * blendFactor;
                        const z = originalPositions.getZ(i) * (1 - blendFactor) + projectedPositions.getZ(i) * blendFactor;
                        
                        const baseIndex = currentIndex * 3;
                        binaryData[baseIndex] = convertFloatToInt8(x);
                        binaryData[baseIndex + 1] = convertFloatToInt8(y);
                        binaryData[baseIndex + 2] = convertFloatToInt8(z);
                        
                        currentIndex++;
                    }
                }
            }
            
            console.log(`Combined BIN export complete: ${binaryData.byteLength} bytes (${currentIndex} points written)`);
            return binaryData.buffer;
        }

        function generatePLY(pointCloud) {
            const originalPositions = pointCloud.geometry.getAttribute('originalPosition');
            const projectedPositions = pointCloud.geometry.getAttribute('projectedPosition');
            const colors = pointCloud.geometry.getAttribute('color');
            const vertices = [];

            // Header
            let ply = 'ply\n';
            ply += 'format ascii 1.0\n';
            ply += `element vertex ${originalPositions.count}\n`;
            ply += 'property float x\n';
            ply += 'property float y\n';
            ply += 'property float z\n';
            ply += 'property uchar red\n';
            ply += 'property uchar green\n';
            ply += 'property uchar blue\n';
            ply += 'end_header\n';

            // Vertex data
            for (let i = 0; i < originalPositions.count; i++) {
                // Interpolate between original and projected based on blendFactor
                const x = originalPositions.getX(i) * (1 - blendFactor) + projectedPositions.getX(i) * blendFactor;
                const y = originalPositions.getY(i) * (1 - blendFactor) + projectedPositions.getY(i) * blendFactor;
                const z = originalPositions.getZ(i) * (1 - blendFactor) + projectedPositions.getZ(i) * blendFactor;
                const r = colors.getX(i);
                const g = colors.getY(i);
                const b = colors.getZ(i);

                ply += `${x} ${y} ${z} ${r} ${g} ${b}\n`;
            }

            return ply;
        }

        function generateCombinedPLY(clouds, totalPoints) {
            // Header
            let ply = 'ply\n';
            ply += 'format ascii 1.0\n';
            ply += `element vertex ${totalPoints}\n`;
            ply += 'property float x\n';
            ply += 'property float y\n';
            ply += 'property float z\n';
            ply += 'property uchar red\n';
            ply += 'property uchar green\n';
            ply += 'property uchar blue\n';
            ply += 'end_header\n';

            // Add vertex data from all clouds
            for (const cloud of clouds) {
                if (cloud.object.visible) {
                    const originalPositions = cloud.object.geometry.getAttribute('originalPosition');
                    const projectedPositions = cloud.object.geometry.getAttribute('projectedPosition');
                    const colors = cloud.object.geometry.getAttribute('color');

                    for (let i = 0; i < originalPositions.count; i++) {
                        // Interpolate between original and projected based on blendFactor
                        const x = originalPositions.getX(i) * (1 - blendFactor) + projectedPositions.getX(i) * blendFactor;
                        const y = originalPositions.getY(i) * (1 - blendFactor) + projectedPositions.getY(i) * blendFactor;
                        const z = originalPositions.getZ(i) * (1 - blendFactor) + projectedPositions.getZ(i) * blendFactor;
                        const r = colors.getX(i);
                        const g = colors.getY(i);
                        const b = colors.getZ(i);

                        ply += `${x} ${y} ${z} ${r} ${g} ${b}\n`;
                    }
                }
            }

            return ply;
        }

        function downloadText(text, filename, mimeType) {
            const blob = new Blob([text], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function downloadBlob(arrayBuffer, filename, mimeType) {
            const blob = new Blob([arrayBuffer], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        // ===== UMAP Infrastructure =====
        let umapWorker = null;

        // Build the Web Worker code as an inline blob
        const umapWorkerCode = `
            'use strict';

            // --- KNN via expanding shell search on integer grid ---
            function buildKNN(cells, gridSize, k) {
                const n = cells.length / 3;
                // 3D lookup: flat array indexed by (x*gs*gs + y*gs + z)
                const gs = gridSize;
                const occupied = new Int32Array(gs * gs * gs).fill(-1);
                for (let i = 0; i < n; i++) {
                    occupied[cells[i * 3] * gs * gs + cells[i * 3 + 1] * gs + cells[i * 3 + 2]] = i;
                }

                const knnIdx = new Int32Array(n * k).fill(-1);
                const knnDist = new Float32Array(n * k);

                for (let i = 0; i < n; i++) {
                    const cx = cells[i * 3], cy = cells[i * 3 + 1], cz = cells[i * 3 + 2];
                    const nbrs = [];

                    for (let r = 1; nbrs.length < k && r <= gs; r++) {
                        for (let dx = -r; dx <= r; dx++) {
                            const nx = cx + dx;
                            if (nx < 0 || nx >= gs) continue;
                            for (let dy = -r; dy <= r; dy++) {
                                const ny = cy + dy;
                                if (ny < 0 || ny >= gs) continue;
                                for (let dz = -r; dz <= r; dz++) {
                                    if (Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz)) !== r) continue;
                                    const nz = cz + dz;
                                    if (nz < 0 || nz >= gs) continue;
                                    const j = occupied[nx * gs * gs + ny * gs + nz];
                                    if (j >= 0 && j !== i) {
                                        nbrs.push({ idx: j, d: Math.sqrt(dx * dx + dy * dy + dz * dz) });
                                    }
                                }
                            }
                        }
                    }

                    nbrs.sort((a, b) => a.d - b.d);
                    const take = Math.min(k, nbrs.length);
                    for (let j = 0; j < take; j++) {
                        knnIdx[i * k + j] = nbrs[j].idx;
                        knnDist[i * k + j] = nbrs[j].d;
                    }

                    if (i % 500 === 0) {
                        self.postMessage({ type: 'progress', phase: 'knn', pct: i / n });
                    }
                }

                return { knnIdx, knnDist };
            }

            // --- Smooth kNN distances (find sigma per point) ---
            function smoothKNN(knnDist, n, k) {
                const rho = new Float32Array(n);
                const sigma = new Float32Array(n);
                const target = Math.log2(k);

                for (let i = 0; i < n; i++) {
                    // rho = distance to nearest neighbor
                    let minD = Infinity;
                    for (let j = 0; j < k; j++) {
                        const d = knnDist[i * k + j];
                        if (d > 0 && d < minD) minD = d;
                    }
                    rho[i] = minD === Infinity ? 0 : minD;

                    // Binary search for sigma
                    let lo = 1e-5, hi = 100, mid = 1;
                    for (let iter = 0; iter < 64; iter++) {
                        mid = (lo + hi) / 2;
                        let sum = 0;
                        for (let j = 0; j < k; j++) {
                            const d = knnDist[i * k + j];
                            const v = Math.max(0, d - rho[i]);
                            sum += Math.exp(-v / mid);
                        }
                        if (Math.abs(sum - target) < 1e-5) break;
                        if (sum > target) lo = mid; else hi = mid;
                    }
                    sigma[i] = mid;
                }
                return { rho, sigma };
            }

            // --- Build symmetrized edge list with weights ---
            function buildGraph(knnIdx, knnDist, rho, sigma, n, k) {
                // Directed weights
                const wMap = new Map();
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < k; j++) {
                        const nbr = knnIdx[i * k + j];
                        if (nbr < 0) continue;
                        const d = Math.max(0, knnDist[i * k + j] - rho[i]);
                        const w = Math.exp(-d / sigma[i]);
                        const key = i < nbr ? i * n + nbr : nbr * n + i;
                        const rev = i < nbr ? false : true;
                        if (!wMap.has(key)) wMap.set(key, { ab: 0, ba: 0 });
                        const entry = wMap.get(key);
                        if ((i < nbr && !rev) || (i >= nbr && rev)) entry.ab = Math.max(entry.ab, w);
                        else entry.ba = Math.max(entry.ba, w);
                    }
                }

                // Symmetrize: w' = a + b - a*b
                const edges = [];
                const weights = [];
                for (const [key, { ab, ba }] of wMap) {
                    const w = ab + ba - ab * ba;
                    if (w > 0.001) {
                        const j = key % n;
                        const i = (key - j) / n;
                        edges.push(i, j);
                        weights.push(w);
                    }
                }
                return { edges: new Int32Array(edges), weights: new Float32Array(weights), edgeCount: weights.length };
            }

            // --- UMAP optimization ---
            function optimizeLayout(embedding, edges, weights, edgeCount, n, nEpochs) {
                // a, b parameters for min_dist=0.1, spread=1.0
                const a = 1.929, b = 0.7915;
                const nNegative = 5;
                const initialAlpha = 1.0;

                // Precompute epochs-per-sample for each edge
                const epochsPerSample = new Float32Array(edgeCount);
                let maxW = 0;
                for (let e = 0; e < edgeCount; e++) maxW = Math.max(maxW, weights[e]);
                for (let e = 0; e < edgeCount; e++) {
                    epochsPerSample[e] = nEpochs / (weights[e] / maxW * nEpochs);
                }
                const epochOfNextSample = new Float32Array(epochsPerSample);

                for (let epoch = 0; epoch < nEpochs; epoch++) {
                    const alpha = initialAlpha * (1.0 - epoch / nEpochs);

                    for (let e = 0; e < edgeCount; e++) {
                        if (epochOfNextSample[e] > epoch) continue;
                        epochOfNextSample[e] += epochsPerSample[e];

                        const i = edges[e * 2];
                        const j = edges[e * 2 + 1];

                        const dx = embedding[i * 2] - embedding[j * 2];
                        const dy = embedding[i * 2 + 1] - embedding[j * 2 + 1];
                        const distSq = dx * dx + dy * dy + 1e-6;

                        // Attractive force
                        const gradCoeff = -2.0 * a * b * Math.pow(distSq, b - 1.0) / (1.0 + a * Math.pow(distSq, b));
                        const gx = gradCoeff * dx;
                        const gy = gradCoeff * dy;
                        const clampedGx = Math.max(-4, Math.min(4, gx));
                        const clampedGy = Math.max(-4, Math.min(4, gy));

                        embedding[i * 2] += alpha * clampedGx;
                        embedding[i * 2 + 1] += alpha * clampedGy;
                        embedding[j * 2] -= alpha * clampedGx;
                        embedding[j * 2 + 1] -= alpha * clampedGy;

                        // Negative sampling (repulsive)
                        for (let neg = 0; neg < nNegative; neg++) {
                            const k = Math.floor(Math.random() * n);
                            if (k === i) continue;
                            const dxn = embedding[i * 2] - embedding[k * 2];
                            const dyn = embedding[i * 2 + 1] - embedding[k * 2 + 1];
                            const distSqN = dxn * dxn + dyn * dyn + 1e-6;

                            const repCoeff = 2.0 * b / ((0.001 + distSqN) * (1.0 + a * Math.pow(distSqN, b)));
                            const rx = Math.max(-4, Math.min(4, repCoeff * dxn));
                            const ry = Math.max(-4, Math.min(4, repCoeff * dyn));

                            embedding[i * 2] += alpha * rx;
                            embedding[i * 2 + 1] += alpha * ry;
                        }
                    }

                    if (epoch % 5 === 0) {
                        self.postMessage({ type: 'progress', phase: 'optimize', pct: epoch / nEpochs, epoch, nEpochs });
                    }
                }

                return embedding;
            }

            // --- Main handler ---
            self.onmessage = function(e) {
                const { cells, cellCount, gridSize, nNeighbors, nEpochs } = e.data;
                const n = cellCount;
                const k = Math.min(nNeighbors, n - 1);

                self.postMessage({ type: 'progress', phase: 'knn', pct: 0 });

                // Step 1: KNN
                const { knnIdx, knnDist } = buildKNN(cells, gridSize, k);
                self.postMessage({ type: 'progress', phase: 'knn', pct: 1 });

                // Step 2: Smooth distances
                self.postMessage({ type: 'progress', phase: 'smooth', pct: 0 });
                const { rho, sigma } = smoothKNN(knnDist, n, k);
                self.postMessage({ type: 'progress', phase: 'smooth', pct: 1 });

                // Step 3: Build graph
                self.postMessage({ type: 'progress', phase: 'graph', pct: 0 });
                const { edges, weights, edgeCount } = buildGraph(knnIdx, knnDist, rho, sigma, n, k);
                self.postMessage({ type: 'progress', phase: 'graph', pct: 1 });

                // Step 4: Initialize embedding (random)
                const embedding = new Float32Array(n * 2);
                for (let i = 0; i < n * 2; i++) {
                    embedding[i] = (Math.random() - 0.5) * 20;
                }

                // Step 5: Optimize
                self.postMessage({ type: 'progress', phase: 'optimize', pct: 0 });
                optimizeLayout(embedding, edges, weights, edgeCount, n, nEpochs);

                self.postMessage({ type: 'complete', embedding });
            };
        `;

        function createUMAPWorker() {
            if (umapWorker) {
                umapWorker.terminate();
                umapWorker = null;
            }
            const blob = new Blob([umapWorkerCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            umapWorker = new Worker(url);
            URL.revokeObjectURL(url);
            return umapWorker;
        }

        function showUMAPProgress(show) {
            document.getElementById('umapProgress').style.display = show ? 'flex' : 'none';
        }

        function updateUMAPProgress(phase, pct) {
            const phaseEl = document.getElementById('umapPhase');
            const barEl = document.getElementById('umapBarFill');
            const pctEl = document.getElementById('umapPct');
            const detailEl = document.getElementById('umapDetail');

            const phaseNames = {
                knn: 'Building neighborhood graph',
                smooth: 'Fitting smooth distances',
                graph: 'Constructing fuzzy simplicial set',
                optimize: 'Optimizing 2D layout'
            };

            // Weight phases for overall progress: knn=30%, smooth=5%, graph=5%, optimize=60%
            const phaseWeights = { knn: 0.30, smooth: 0.05, graph: 0.05, optimize: 0.60 };
            const phaseStarts = { knn: 0, smooth: 0.30, graph: 0.35, optimize: 0.40 };

            const overall = phaseStarts[phase] + pct * phaseWeights[phase];
            const overallPct = Math.round(overall * 100);

            phaseEl.textContent = phaseNames[phase] || phase;
            barEl.style.width = overallPct + '%';
            pctEl.textContent = overallPct + '%';

            if (phase === 'optimize' && pct > 0) {
                detailEl.textContent = `epoch ${Math.round(pct * 200)} / 200`;
            } else {
                detailEl.textContent = '';
            }
        }

        function triggerUMAPForAllClouds(bits) {
            const gridSize = Math.pow(2, bits);
            const allClouds = [];

            pointClouds.forEach((cloud, id) => {
                allClouds.push({ cloud, id });
            });

            if (allClouds.length === 0) return;

            // Merge all cloud positions for a single joint UMAP
            // Quantize into cells, track which cell each point belongs to
            const cellMap = new Map(); // key "x,y,z" -> cellIndex
            const cellList = [];       // flat: [x, y, z, x, y, z, ...]
            const cellCounts = [];
            let cellIndex = 0;

            // For each cloud, record cell assignments
            const cloudCellAssignments = [];

            for (const { cloud } of allClouds) {
                const pos = cloud.originalPositions;
                const numPts = pos.length / 3;
                const assignments = new Int32Array(numPts);

                for (let i = 0; i < numPts; i++) {
                    const x = pos[i * 3];
                    const y = pos[i * 3 + 1];
                    const z = pos[i * 3 + 2];

                    // Quantize from [-1,1] to [0, gridSize-1]
                    const qx = Math.max(0, Math.min(gridSize - 1, Math.floor((x + 1) / 2 * gridSize)));
                    const qy = Math.max(0, Math.min(gridSize - 1, Math.floor((y + 1) / 2 * gridSize)));
                    const qz = Math.max(0, Math.min(gridSize - 1, Math.floor((z + 1) / 2 * gridSize)));

                    const key = qx + ',' + qy + ',' + qz;
                    if (!cellMap.has(key)) {
                        cellMap.set(key, cellIndex);
                        cellList.push(qx, qy, qz);
                        cellCounts.push(0);
                        cellIndex++;
                    }
                    const ci = cellMap.get(key);
                    cellCounts[ci]++;
                    assignments[i] = ci;
                }

                cloudCellAssignments.push(assignments);
            }

            const cellCount = cellIndex;
            console.log(`UMAP: ${cellCount} occupied cells at ${bits}-bit quantization`);

            if (cellCount < 3) {
                console.log('Too few occupied cells for UMAP');
                return;
            }

            showUMAPProgress(true);
            updateUMAPProgress('knn', 0);

            const worker = createUMAPWorker();

            const cancelBtn = document.getElementById('umapCancelBtn');
            cancelBtn.onclick = () => {
                worker.terminate();
                umapWorker = null;
                showUMAPProgress(false);
                // Revert to tiled projection
                currentProjection = 'tiled';
                document.getElementById('projectionSelect').value = 'tiled';
                document.getElementById('projectionLabel').textContent = 'Tiled';
                document.getElementById('quantizationGroup').style.display = 'flex';
                pointClouds.forEach(c => updateProjectedPositions(c));
            };

            worker.onmessage = function(evt) {
                const msg = evt.data;
                if (msg.type === 'progress') {
                    updateUMAPProgress(msg.phase, msg.pct);
                } else if (msg.type === 'complete') {
                    showUMAPProgress(false);
                    const embedding = msg.embedding; // Float32Array, n*2

                    // Normalize embedding to [-1, 1]
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (let i = 0; i < cellCount; i++) {
                        const ex = embedding[i * 2], ey = embedding[i * 2 + 1];
                        if (ex < minX) minX = ex; if (ex > maxX) maxX = ex;
                        if (ey < minY) minY = ey; if (ey > maxY) maxY = ey;
                    }
                    const rangeX = maxX - minX || 1;
                    const rangeY = maxY - minY || 1;
                    const scale = Math.max(rangeX, rangeY);
                    const cx = (minX + maxX) / 2;
                    const cy = (minY + maxY) / 2;

                    const cellPositions = new Float32Array(cellCount * 2);
                    for (let i = 0; i < cellCount; i++) {
                        cellPositions[i * 2]     = ((embedding[i * 2] - cx) / scale) * 1.8;
                        cellPositions[i * 2 + 1] = ((embedding[i * 2 + 1] - cy) / scale) * 1.8;
                    }

                    // Compute intra-cell spread radius based on cell density in UMAP space
                    // Use a fraction of the average nearest-neighbor distance in 2D
                    let avgNNDist = 0;
                    const nnCount = Math.min(5, cellCount - 1);
                    // Simple: sample up to 200 cells, find avg NN dist
                    const sampleSize = Math.min(200, cellCount);
                    const step = Math.max(1, Math.floor(cellCount / sampleSize));
                    let sampleCount = 0;
                    for (let i = 0; i < cellCount; i += step) {
                        let minD = Infinity;
                        for (let j = 0; j < cellCount; j++) {
                            if (i === j) continue;
                            const dx = cellPositions[i * 2] - cellPositions[j * 2];
                            const dy = cellPositions[i * 2 + 1] - cellPositions[j * 2 + 1];
                            const d = Math.sqrt(dx * dx + dy * dy);
                            if (d < minD) minD = d;
                        }
                        avgNNDist += minD;
                        sampleCount++;
                    }
                    avgNNDist /= sampleCount;
                    const intraRadius = avgNNDist * 0.3;

                    // Map each original point to its UMAP cell + intra-cell offset
                    for (let ci = 0; ci < allClouds.length; ci++) {
                        const { cloud, id } = allClouds[ci];
                        const pos = cloud.originalPositions;
                        const numPts = pos.length / 3;
                        const assignments = cloudCellAssignments[ci];
                        const projected = new Float32Array(numPts * 3);

                        for (let i = 0; i < numPts; i++) {
                            const cellIdx = assignments[i];
                            const cellBaseX = cellPositions[cellIdx * 2];
                            const cellBaseY = cellPositions[cellIdx * 2 + 1];

                            // Intra-cell offset: use the fractional position within the cell
                            const x = pos[i * 3];
                            const y = pos[i * 3 + 1];
                            const z = pos[i * 3 + 2];

                            // Get fractional position within cell [0,1)
                            const fx = ((x + 1) / 2 * gridSize) % 1;
                            const fy = ((y + 1) / 2 * gridSize) % 1;
                            const fz = ((z + 1) / 2 * gridSize) % 1;

                            // Map 3D intra-cell to 2D offset using a small tiled layout
                            // z-axis -> small angular offset, x/y -> direct offset
                            const angle = fz * Math.PI * 2;
                            const offX = (fx - 0.5) * intraRadius * 0.7 + Math.cos(angle) * fz * intraRadius * 0.3;
                            const offY = (fy - 0.5) * intraRadius * 0.7 + Math.sin(angle) * fz * intraRadius * 0.3;

                            projected[i * 3]     = cellBaseX + offX;
                            projected[i * 3 + 1] = cellBaseY + offY;
                            projected[i * 3 + 2] = 0;
                        }

                        cloud.umapProjectedPositions = projected;
                        cloud.object.geometry.setAttribute('projectedPosition',
                            new THREE.Float32BufferAttribute(projected, 3));
                    }

                    console.log(`UMAP complete: ${cellCount} cells mapped`);
                    worker.terminate();
                    umapWorker = null;
                }
            };

            worker.onerror = function(err) {
                console.error('UMAP worker error:', err);
                showUMAPProgress(false);
                worker.terminate();
                umapWorker = null;
            };

            // Determine neighbor count based on cell count
            const nNeighbors = cellCount < 100 ? Math.min(10, cellCount - 1) : 15;
            const nEpochs = 200;

            worker.postMessage({
                cells: new Int32Array(cellList),
                cellCount,
                gridSize,
                nNeighbors,
                nEpochs
            });
        }

        // ===== End UMAP Infrastructure =====

        init();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update point size for all shaders based on new screen size
            pointClouds.forEach(cloud => {
                if (cloud.object.material.uniforms) {
                    cloud.object.material.uniforms.pointSize.value = cloud.pointSizeBase * Math.max(window.innerWidth, window.innerHeight) / 100;
                }
            });
        });

        const argument = new URL(document.URL).searchParams.get('fetch');
        if (argument) {
            console.log(argument);
            tryFetchAPI(argument);
        }

        // Handle file input
        document.getElementById('fileInput').addEventListener('change', function (e) {
            handleFiles(e.target.files);
        });
    </script>
</body>
</html>