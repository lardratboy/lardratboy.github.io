<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Color Isolation Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        #dropZone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: none;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
            font-size: 24px;
            flex-direction: column;
        }

        #dropZone .drop-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: bold;
            color: #555;
        }

        input[type="file"] {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #007bff;
        }

        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .images-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-section {
            text-align: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }

        .image-section h3 {
            margin-top: 0;
            color: #333;
            font-size: 16px;
        }

        .image-section canvas {
            max-width: 100%;
            border: 2px solid #ddd;
            border-radius: 4px;
            background: white;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 5px;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .footer {
            margin-top: 30px;
            padding: 15px;
            text-align: center;
            color: #888;
            font-size: 14px;
            border-top: 1px solid #eee;
            background: #fafafa;
            border-radius: 0 0 10px 10px;
        }
    </style>
</head>
<body>
    <div id="dropZone">
        <div class="drop-icon">üñºÔ∏è</div>
        <div>Drop images here or paste from clipboard</div>
        <div style="font-size: 16px; margin-top: 10px; opacity: 0.8;">
            Supports files, URLs, and images from web pages
        </div>

        <div class="footer">
            üí° You can also drag/drop images, paste from clipboard (Ctrl+V), or drag images from web pages
        </div>
    </div>
    
    <div class="container">
        <h1>üé® Image Color Isolation Tool</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="fileInput">Choose Image:</label>
                <input type="file" id="fileInput" accept="image/*">
            </div>
            
            <div class="control-group">
                <label for="replacementColor">Replacement Color:</label>
                <input type="color" id="replacementColor" value="#ff00ff">
            </div>
            
            <div class="control-group">
                <label for="sortType">Sort Palette By:</label>
                <select id="sortType">
                    <option value="frequency">Frequency</option>
                    <option value="hue">Hue</option>
                    <option value="discovery">Discovery Order</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="processBtn" disabled>Process Image</button>
            </div>
        </div>

        <div id="loadingIndicator" class="loading" style="display: none;">
            Processing image...
        </div>

        <div class="images-container" id="imagesContainer" style="display: none;">
            <div class="image-section">
                <h3>Original Image</h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            
            <div class="image-section">
                <h3>Isolated Colors</h3>
                <canvas id="isolatedCanvas"></canvas>
            </div>
            
            <div class="image-section">
                <h3>Color Palette</h3>
                <canvas id="paletteCanvas"></canvas>
            </div>
        </div>

        <div class="stats" id="statsContainer" style="display: none;">
            <h3>Analysis Results</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Image Dimensions</div>
                    <div class="stat-value" id="imageDimensions">0 √ó 0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Pixels</div>
                    <div class="stat-value" id="totalPixels">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Unique Colors</div>
                    <div class="stat-value" id="uniqueColorsCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Color Density</div>
                    <div class="stat-value" id="colorDensity">0%</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Processing Time</div>
                    <div class="stat-value" id="processingTime">0ms</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced function to get unique colors with all metadata for sorting
        function getUniqueColorsWithMetadata(data) {
            const colorData = new Map();
            let discoveryOrder = 0;
            
            for (let i = 0; i < data.length; i += 4) { // RGBA format, so step by 4
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const colorKey = (r << 16) | (g << 8) | b;
                
                if (!colorData.has(colorKey)) {
                    colorData.set(colorKey, {
                        r: r,
                        g: g,
                        b: b,
                        frequency: 1,
                        discoveryOrder: discoveryOrder++,
                        hue: rgbToHue(r, g, b)
                    });
                } else {
                    colorData.get(colorKey).frequency++;
                }
            }
            
            return Array.from(colorData.values());
        }

        // Convert RGB to Hue (0-360 degrees)
        function rgbToHue(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;
            
            if (delta === 0) return 0; // Gray
            
            let hue;
            if (max === r) {
                hue = ((g - b) / delta) % 6;
            } else if (max === g) {
                hue = (b - r) / delta + 2;
            } else {
                hue = (r - g) / delta + 4;
            }
            
            hue = Math.round(hue * 60);
            if (hue < 0) hue += 360;
            
            return hue;
        }

        // Sort colors based on selected method
        function sortColors(colors, sortType) {
            switch (sortType) {
                case 'frequency':
                    return colors.sort((a, b) => b.frequency - a.frequency);
                
                case 'hue':
                    return colors.sort((a, b) => {
                        if (a.hue !== b.hue) return a.hue - b.hue;
                        // If hues are equal, sort by saturation/brightness
                        const aSat = getSaturation(a.r, a.g, a.b);
                        const bSat = getSaturation(b.r, b.g, b.b);
                        return bSat - aSat;
                    });
                
                case 'discovery':
                    return colors.sort((a, b) => a.discoveryOrder - b.discoveryOrder);
                
                default:
                    return colors;
            }
        }

        // Helper function to get saturation for tie-breaking in hue sort
        function getSaturation(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            
            if (max === 0) return 0;
            return (max - min) / max;
        }

        class ColorIsolationTool {
            constructor() {
                this.fileInput = document.getElementById('fileInput');
                this.replacementColorInput = document.getElementById('replacementColor');
                this.sortTypeSelect = document.getElementById('sortType');
                this.processBtn = document.getElementById('processBtn');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.imagesContainer = document.getElementById('imagesContainer');
                this.statsContainer = document.getElementById('statsContainer');
                
                this.originalCanvas = document.getElementById('originalCanvas');
                this.isolatedCanvas = document.getElementById('isolatedCanvas');
                this.paletteCanvas = document.getElementById('paletteCanvas');
                
                this.originalCtx = this.originalCanvas.getContext('2d');
                this.isolatedCtx = this.isolatedCanvas.getContext('2d');
                this.paletteCtx = this.paletteCanvas.getContext('2d');
                
                this.setupEventListeners();
                this.setupDropZone();
                this.setupClipboard();
            }

            setupEventListeners() {
                this.fileInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.handleFiles([e.target.files[0]]);
                    }
                });

                this.processBtn.addEventListener('click', () => {
                    this.processImage();
                });

                // Allow re-sorting without reprocessing the whole image
                this.sortTypeSelect.addEventListener('change', () => {
                    if (this.lastColorData && this.lastImageData) {
                        this.updatePaletteSort();
                    }
                });
            }

            setupDropZone() {
                const dropZone = document.getElementById('dropZone');

                document.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    dropZone.style.display = 'flex';
                });

                dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    if (e.target === dropZone) {
                        dropZone.style.display = 'none';
                    }
                });

                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.style.display = 'none';
                    this.handleDrop(e);
                });
            }

            setupClipboard() {
                document.addEventListener('paste', (e) => {
                    e.preventDefault();
                    const items = (e.clipboardData || window.clipboardData).items;
                    for (let item of items) {
                        if (item.kind === 'file' && item.type.startsWith('image/')) {
                            const file = item.getAsFile();
                            this.handleFiles([file]);
                            return;
                        } else if (item.kind === 'string') {
                            item.getAsString((text) => {
                                this.tryFetchAPI(text);
                            });
                        }
                    }
                });
            }

            handleDrop(e) {
                const dt = e.dataTransfer;
                const file = dt.files[0];

                if (file && file.type.startsWith('image/')) {
                    this.handleFiles([file]);
                    return;
                }

                // Handle non-file drops (URLs, HTML content, etc.)
                for (let i = 0; i < dt.items.length; i++) {
                    const item = dt.items[i];
                    if (item.kind === 'string') {
                        item.getAsString((s) => {
                            this.handleNonFileDrop(s);
                        });
                    }
                }
            }

            async tryFetchAPI(src) {
                // Skip if it doesn't look like a URL
                if (!src.startsWith('http://') && !src.startsWith('https://')) {
                    return;
                }

                try {
                    console.log('Attempting to fetch:', src);
                    const response = await fetch(src);
                    if (response.ok && response.headers.get('content-type')?.startsWith('image/')) {
                        const blob = await response.blob();
                        const file = new File([blob], 'fetched-image', { type: blob.type });
                        this.handleFiles([file]);
                    }
                } catch (error) {
                    console.log('Fetch failed:', error.message);
                }
            }

            handleNonFileDrop(text) {
                // Try direct URL first
                if (text.startsWith('http://') || text.startsWith('https://')) {
                    this.tryFetchAPI(text);
                    return;
                }

                // Handle HTML content (like when dragging images from web pages)
                if (text.includes('<img') || text.startsWith('<meta')) {
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'text/html');
                        
                        // Look for img tags
                        const imgElement = doc.querySelector('img');
                        if (imgElement) {
                            const imgSrc = imgElement.getAttribute('src');
                            if (imgSrc) {
                                // Handle relative URLs
                                if (imgSrc.startsWith('//')) {
                                    this.tryFetchAPI('https:' + imgSrc);
                                } else if (imgSrc.startsWith('/')) {
                                    // Can't handle relative paths without domain context
                                    console.log('Cannot fetch relative URL without domain context');
                                } else {
                                    this.tryFetchAPI(imgSrc);
                                }
                            }
                        }
                    } catch (error) {
                        console.log('Failed to parse HTML content:', error.message);
                    }
                }
            }

            handleFiles(files) {
                if (!files || files.length === 0) return;
                
                const file = files[0]; // Take first file only
                if (!file.type.startsWith('image/')) {
                    console.log('File is not an image:', file.type);
                    return;
                }

                console.log('Processing image file:', file.name);
                
                // Update file input to show the processed file
                this.fileInput.files = null;
                this.processBtn.disabled = false;
                
                // Process the image
                this.currentFile = file;
                this.processImageFromFile(file);
            }

            async processImageFromFile(file) {
                this.showLoading(true);
                const startTime = performance.now();

                try {
                    // Load image
                    const img = await this.loadImageFromFile(file);
                    
                    // Setup canvases
                    this.setupCanvases(img);
                    
                    // Get image data
                    const imageData = this.getImageData(img);
                    
                    // Find unique colors with all metadata
                    const colorData = getUniqueColorsWithMetadata(imageData.data);
                    console.log(`Found ${colorData.length} unique colors`);
                    
                    // Store for re-sorting
                    this.lastColorData = colorData;
                    this.lastImageData = imageData;
                    
                    // Sort colors based on selected method
                    const sortType = this.sortTypeSelect.value;
                    const sortedColors = sortColors([...colorData], sortType);
                    
                    // Create isolated image using the sorted color data
                    this.createIsolatedImage(imageData, sortedColors);
                    
                    // Create color palette (sorted by selected method)
                    this.createColorPalette(sortedColors, sortType);
                    
                    // Update stats
                    const endTime = performance.now();
                    this.updateStats(sortedColors, imageData, endTime - startTime);
                    
                    this.showResults(true);
                } catch (error) {
                    console.error('Error processing image:', error);
                } finally {
                    this.showLoading(false);
                }
            }

            loadImageFromFile(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            async processImage() {
                const file = this.fileInput.files[0];
                if (!file) return;

                this.processImageFromFile(file);
            }

            updatePaletteSort() {
                if (!this.lastColorData) return;
                
                const sortType = this.sortTypeSelect.value;
                const sortedColors = sortColors([...this.lastColorData], sortType);
                
                // Only update the palette, keep other images the same
                this.createColorPalette(sortedColors, sortType);
                console.log(`Palette re-sorted by: ${sortType}`);
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            setupCanvases(img) {
                // Set up original canvas
                this.originalCanvas.width = img.width;
                this.originalCanvas.height = img.height;
                this.originalCtx.drawImage(img, 0, 0);

                // Set up isolated canvas
                this.isolatedCanvas.width = img.width;
                this.isolatedCanvas.height = img.height;
            }

            getImageData(img) {
                this.originalCtx.drawImage(img, 0, 0);
                return this.originalCtx.getImageData(0, 0, img.width, img.height);
            }

            createIsolatedImage(imageData, sortedColors) {
                const isolatedData = this.isolatedCtx.createImageData(imageData.width, imageData.height);
                const colorMap = new Map();
                
                // Create lookup map for unique colors
                for (const colorObj of sortedColors) {
                    const key = (colorObj.r << 16) | (colorObj.g << 8) | colorObj.b;
                    colorMap.set(key, { r: colorObj.r, g: colorObj.g, b: colorObj.b });
                }

                // Get replacement color
                const replacementHex = this.replacementColorInput.value;
                const replacementColor = {
                    r: parseInt(replacementHex.substr(1, 2), 16),
                    g: parseInt(replacementHex.substr(3, 2), 16),
                    b: parseInt(replacementHex.substr(5, 2), 16)
                };

                const usedColors = new Set();

                // Process each pixel
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    const a = imageData.data[i + 3];

                    const colorKey = (r << 16) | (g << 8) | b;

                    if (usedColors.has(colorKey)) {
                        // Use replacement color for already seen colors
                        isolatedData.data[i] = replacementColor.r;
                        isolatedData.data[i + 1] = replacementColor.g;
                        isolatedData.data[i + 2] = replacementColor.b;
                    } else {
                        // First occurrence - use original color
                        isolatedData.data[i] = r;
                        isolatedData.data[i + 1] = g;
                        isolatedData.data[i + 2] = b;
                        usedColors.add(colorKey);
                    }
                    
                    isolatedData.data[i + 3] = a; // Alpha
                }

                this.isolatedCtx.putImageData(isolatedData, 0, 0);
            }

            createColorPalette(sortedColors, sortType) {
                const numColors = sortedColors.length;
                console.log(`Creating palette for ${numColors} unique colors (sorted by ${sortType})`);
                
                if (numColors === 0) {
                    console.log('No colors to display in palette');
                    return;
                }
                
                // Calculate square size needed
                const paletteSize = Math.ceil(Math.sqrt(numColors));
                
                this.paletteCanvas.width = paletteSize;
                this.paletteCanvas.height = paletteSize;
                
                console.log(`Palette canvas: ${paletteSize}x${paletteSize} for ${numColors} colors`);
                
                // Log sorting-specific info
                if (sortType === 'frequency') {
                    console.log(`Most frequent color: rgb(${sortedColors[0].r}, ${sortedColors[0].g}, ${sortedColors[0].b}) appears ${sortedColors[0].frequency} times`);
                } else if (sortType === 'hue') {
                    console.log(`First hue: ${sortedColors[0].hue}¬∞ - rgb(${sortedColors[0].r}, ${sortedColors[0].g}, ${sortedColors[0].b})`);
                } else if (sortType === 'discovery') {
                    console.log(`First discovered color: rgb(${sortedColors[0].r}, ${sortedColors[0].g}, ${sortedColors[0].b})`);
                }
                
                // Create ImageData - one pixel per color
                const imageData = this.paletteCtx.createImageData(paletteSize, paletteSize);
                const data = imageData.data;
                
                // Fill with white background first
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255;     // R
                    data[i + 1] = 255; // G  
                    data[i + 2] = 255; // B
                    data[i + 3] = 255; // A
                }
                
                // Set each color directly - one pixel per unique color (sorted by selected method)
                for (let i = 0; i < numColors; i++) {
                    const pixelIndex = i * 4;
                    const color = sortedColors[i];
                    
                    data[pixelIndex] = color.r;         // R
                    data[pixelIndex + 1] = color.g;     // G
                    data[pixelIndex + 2] = color.b;     // B
                    data[pixelIndex + 3] = 255;         // A
                }
                
                // Put the pixel data to canvas
                this.paletteCtx.putImageData(imageData, 0, 0);
                console.log(`Palette creation completed - 1:1 pixel mapping, sorted by ${sortType}`);
            }

            updateStats(sortedColors, imageData, processingTime) {
                const uniqueCount = sortedColors.length;
                const totalPixels = imageData.width * imageData.height;
                const colorDensity = ((uniqueCount / totalPixels) * 100).toFixed(2);

                document.getElementById('imageDimensions').textContent = `${imageData.width} √ó ${imageData.height}`;
                document.getElementById('totalPixels').textContent = totalPixels.toLocaleString();
                document.getElementById('uniqueColorsCount').textContent = uniqueCount.toLocaleString();
                document.getElementById('colorDensity').textContent = `${colorDensity}%`;
                document.getElementById('processingTime').textContent = `${Math.round(processingTime)}ms`;
            }

            showLoading(show) {
                this.loadingIndicator.style.display = show ? 'block' : 'none';
                this.processBtn.disabled = show;
            }

            showResults(show) {
                this.imagesContainer.style.display = show ? 'grid' : 'none';
                this.statsContainer.style.display = show ? 'block' : 'none';
            }
        }

        // Initialize the tool when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ColorIsolationTool();
        });
    </script>
</body>
</html>